// <auto-generated />
using System.Text.RegularExpressions;
using System.Runtime.CompilerServices;

/// <summary>
/// Splits Polyfill source files by target framework, evaluating conditional compilations.
/// Unknown symbols (like Feature*) are preserved in the output.
/// </summary>
public class Splitter
{
    static readonly string SolutionDir = FindSolutionDirectory();
    static readonly string PolyfillDir = Path.Combine(SolutionDir, "Polyfill");

    /// <summary>
    /// The directory where split files are written.
    /// </summary>
    public static readonly string SplitOutputDir = Path.Combine(SolutionDir, "Split");

    /// <summary>
    /// Finds the solution directory by navigating up from the source file location.
    /// Falls back to ProjectFiles.SolutionDirectory if the source file approach fails.
    /// </summary>
    static string FindSolutionDirectory([CallerFilePath] string sourceFilePath = "")
    {
        // Try to find the solution directory from the source file path
        // The source file is at: src/ApiBuilderTests/Splitter.cs
        // The solution directory is: src/
        if (!string.IsNullOrEmpty(sourceFilePath))
        {
            var dir = Path.GetDirectoryName(sourceFilePath);
            if (dir != null)
            {
                var parentDir = Path.GetDirectoryName(dir);
                if (parentDir != null && Directory.Exists(Path.Combine(parentDir, "Polyfill")))
                {
                    return parentDir;
                }
            }
        }

        // Fall back to ProjectFiles.SolutionDirectory
        return ProjectFiles.SolutionDirectory;
    }

    /// <summary>
    /// All target frameworks to generate splits for.
    /// </summary>
    public static readonly string[] TargetFrameworks =
    [
        "net461",
        "net462",
        "net47",
        "net471",
        "net472",
        "net48",
        "net481",
        "netstandard2.0",
        "netstandard2.1",
        "netcoreapp2.0",
        "netcoreapp2.1",
        "netcoreapp2.2",
        "netcoreapp3.0",
        "netcoreapp3.1",
        "net5.0",
        "net6.0",
        "net7.0",
        "net8.0",
        "net9.0",
        "net10.0"
    ];

    /// <summary>
    /// All known framework monikers that should be evaluated (not left in output).
    /// This includes all the _OR_GREATER variants and X-suffixed monikers.
    /// </summary>
    public static readonly HashSet<string> AllKnownFrameworkSymbols = BuildAllKnownSymbols();

    static HashSet<string> BuildAllKnownSymbols()
    {
        var symbols = new HashSet<string>(StringComparer.OrdinalIgnoreCase);

        // Add all specific version symbols
        foreach (var tfm in TargetFrameworks)
        {
            var symbolsForTfm = GetPreprocessorSymbolsForFramework(tfm);
            foreach (var sym in symbolsForTfm)
            {
                symbols.Add(sym);
            }
        }

        // Add X-suffixed symbols
        symbols.Add("NETCOREAPP2X");
        symbols.Add("NETCOREAPP3X");
        symbols.Add("NETCOREAPPX");
        symbols.Add("NET46X");
        symbols.Add("NET47X");
        symbols.Add("NET48X");
        symbols.Add("NETCOREAPP");
        symbols.Add("NETFRAMEWORK");
        symbols.Add("NETSTANDARD");

        return symbols;
    }

    /// <summary>
    /// Gets the preprocessor symbols defined for a given target framework.
    /// </summary>
    public static HashSet<string> GetPreprocessorSymbolsForFramework(string targetFramework)
    {
        var symbols = new HashSet<string>(StringComparer.OrdinalIgnoreCase);
        var tfm = targetFramework.ToLowerInvariant();

        // NET Framework
        if (tfm.StartsWith("net4"))
        {
            symbols.Add("NETFRAMEWORK");

            if (tfm.StartsWith("net46"))
            {
                symbols.Add("NET46X");
                if (tfm == "net461")
                {
                    symbols.Add("NET461");
                    symbols.Add("NET461_OR_GREATER");
                }
                else if (tfm == "net462")
                {
                    symbols.Add("NET462");
                    symbols.Add("NET462_OR_GREATER");
                    symbols.Add("NET461_OR_GREATER");
                }
            }
            else if (tfm.StartsWith("net47"))
            {
                symbols.Add("NET47X");
                symbols.Add("NET461_OR_GREATER");
                symbols.Add("NET462_OR_GREATER");

                if (tfm == "net47")
                {
                    symbols.Add("NET47");
                    symbols.Add("NET47_OR_GREATER");
                }
                else if (tfm == "net471")
                {
                    symbols.Add("NET471");
                    symbols.Add("NET471_OR_GREATER");
                    symbols.Add("NET47_OR_GREATER");
                }
                else if (tfm == "net472")
                {
                    symbols.Add("NET472");
                    symbols.Add("NET472_OR_GREATER");
                    symbols.Add("NET471_OR_GREATER");
                    symbols.Add("NET47_OR_GREATER");
                }
            }
            else if (tfm.StartsWith("net48"))
            {
                symbols.Add("NET48X");
                symbols.Add("NET461_OR_GREATER");
                symbols.Add("NET462_OR_GREATER");
                symbols.Add("NET47_OR_GREATER");
                symbols.Add("NET471_OR_GREATER");
                symbols.Add("NET472_OR_GREATER");

                if (tfm == "net48")
                {
                    symbols.Add("NET48");
                    symbols.Add("NET48_OR_GREATER");
                }
                else if (tfm == "net481")
                {
                    symbols.Add("NET481");
                    symbols.Add("NET481_OR_GREATER");
                    symbols.Add("NET48_OR_GREATER");
                }
            }
        }
        // .NET Standard
        else if (tfm.StartsWith("netstandard"))
        {
            symbols.Add("NETSTANDARD");

            if (tfm == "netstandard2.0")
            {
                symbols.Add("NETSTANDARD2_0");
                symbols.Add("NETSTANDARD2_0_OR_GREATER");
            }
            else if (tfm == "netstandard2.1")
            {
                symbols.Add("NETSTANDARD2_1");
                symbols.Add("NETSTANDARD2_1_OR_GREATER");
                symbols.Add("NETSTANDARD2_0_OR_GREATER");
            }
        }
        // .NET Core
        else if (tfm.StartsWith("netcoreapp"))
        {
            symbols.Add("NETCOREAPP");
            symbols.Add("NETCOREAPPX");

            if (tfm.StartsWith("netcoreapp2"))
            {
                symbols.Add("NETCOREAPP2X");

                if (tfm == "netcoreapp2.0")
                {
                    symbols.Add("NETCOREAPP2_0");
                    symbols.Add("NETCOREAPP2_0_OR_GREATER");
                }
                else if (tfm == "netcoreapp2.1")
                {
                    symbols.Add("NETCOREAPP2_1");
                    symbols.Add("NETCOREAPP2_1_OR_GREATER");
                    symbols.Add("NETCOREAPP2_0_OR_GREATER");
                }
                else if (tfm == "netcoreapp2.2")
                {
                    symbols.Add("NETCOREAPP2_2");
                    symbols.Add("NETCOREAPP2_2_OR_GREATER");
                    symbols.Add("NETCOREAPP2_1_OR_GREATER");
                    symbols.Add("NETCOREAPP2_0_OR_GREATER");
                }
            }
            else if (tfm.StartsWith("netcoreapp3"))
            {
                symbols.Add("NETCOREAPP3X");
                symbols.Add("NETCOREAPP2_0_OR_GREATER");
                symbols.Add("NETCOREAPP2_1_OR_GREATER");
                symbols.Add("NETCOREAPP2_2_OR_GREATER");

                if (tfm == "netcoreapp3.0")
                {
                    symbols.Add("NETCOREAPP3_0");
                    symbols.Add("NETCOREAPP3_0_OR_GREATER");
                }
                else if (tfm == "netcoreapp3.1")
                {
                    symbols.Add("NETCOREAPP3_1");
                    symbols.Add("NETCOREAPP3_1_OR_GREATER");
                    symbols.Add("NETCOREAPP3_0_OR_GREATER");
                }
            }
        }
        // .NET 5+
        else if (tfm.StartsWith("net"))
        {
            // Parse version number
            var versionStr = tfm.Substring(3).Replace(".", "_");
            var match = Regex.Match(versionStr, @"^(\d+)");
            if (match.Success && int.TryParse(match.Groups[1].Value, out var majorVersion) && majorVersion >= 5)
            {
                var netSymbol = $"NET{versionStr.Replace("_0", "_0")}";
                if (!netSymbol.Contains("_"))
                {
                    netSymbol += "_0";
                }
                symbols.Add(netSymbol);
                symbols.Add($"{netSymbol}_OR_GREATER");

                // Add all previous _OR_GREATER symbols
                for (var v = 5; v < majorVersion; v++)
                {
                    symbols.Add($"NET{v}_0_OR_GREATER");
                }

                // .NET 5+ also defines legacy NETCOREAPP symbols for backwards compatibility
                symbols.Add("NETCOREAPP");
                symbols.Add("NETCOREAPP2_0_OR_GREATER");
                symbols.Add("NETCOREAPP2_1_OR_GREATER");
                symbols.Add("NETCOREAPP3_0_OR_GREATER");
                symbols.Add("NETCOREAPP3_1_OR_GREATER");
            }
        }

        return symbols;
    }

    /// <summary>
    /// Processes all .cs files in the Polyfill directory and writes split versions for each target framework.
    /// </summary>
    public static void Run()
    {
        // Clean up existing split directory
        if (Directory.Exists(SplitOutputDir))
        {
            Directory.Delete(SplitOutputDir, true);
        }

        var csFiles = Directory.EnumerateFiles(PolyfillDir, "*.cs", SearchOption.AllDirectories)
            .Where(f => !f.Contains("\\obj\\") && !f.Contains("/obj/"))
            .ToList();

        foreach (var targetFramework in TargetFrameworks)
        {
            var outputDir = Path.Combine(SplitOutputDir, targetFramework);
            Directory.CreateDirectory(outputDir);

            var definedSymbols = GetPreprocessorSymbolsForFramework(targetFramework);

            foreach (var csFile in csFiles)
            {
                var relativePath = Path.GetRelativePath(PolyfillDir, csFile);
                var outputPath = Path.Combine(outputDir, relativePath);
                var outputFileDir = Path.GetDirectoryName(outputPath)!;
                Directory.CreateDirectory(outputFileDir);

                var sourceCode = File.ReadAllText(csFile);
                var processedCode = ProcessFile(sourceCode, definedSymbols);

                // Normalize newlines to \r\n
                processedCode = NormalizeNewlines(processedCode);

                File.WriteAllText(outputPath, processedCode);
            }
        }
    }

    /// <summary>
    /// Normalizes all newlines to \r\n.
    /// </summary>
    public static string NormalizeNewlines(string text)
    {
        // First normalize all to \n, then convert to \r\n
        text = text.Replace("\r\n", "\n").Replace("\r", "\n");
        return text.Replace("\n", "\r\n");
    }

    /// <summary>
    /// Processes a single source file, evaluating conditional compilations based on defined symbols.
    /// Unknown symbols are preserved in the output.
    /// </summary>
    public static string ProcessFile(string sourceCode, HashSet<string> definedSymbols)
    {
        var processor = new ConditionalProcessor(sourceCode, definedSymbols);
        return processor.Process();
    }
}

/// <summary>
/// Processes conditional compilation directives in source code.
/// Evaluates known framework symbols and preserves unknown symbols.
/// </summary>
public class ConditionalProcessor
{
    readonly string _sourceCode;
    readonly HashSet<string> _definedSymbols;
    readonly List<string> _lines;
    readonly List<string> _outputLines;

    public ConditionalProcessor(string sourceCode, HashSet<string> definedSymbols)
    {
        _sourceCode = sourceCode;
        _definedSymbols = definedSymbols;
        _lines = sourceCode.Split('\n').Select(l => l.TrimEnd('\r')).ToList();
        _outputLines = [];
    }

    public string Process()
    {
        var state = new Stack<ConditionalState>();
        var i = 0;

        while (i < _lines.Count)
        {
            var line = _lines[i];
            var trimmed = line.TrimStart();

            if (trimmed.StartsWith("#if ") || trimmed.StartsWith("#if("))
            {
                var expression = ExtractExpression(trimmed, "#if");
                var evalResult = EvaluateExpression(expression);

                state.Push(new ConditionalState
                {
                    OriginalExpression = expression,
                    EvalResult = evalResult,
                    SimplifiedExpression = SimplifyExpression(expression),
                    BranchTaken = evalResult == TriState.True || evalResult == TriState.Unknown,
                    HasElse = false,
                    ElseEvalResult = null,
                    Line = i
                });

                if (evalResult == TriState.Unknown)
                {
                    // Keep the directive but with simplified expression
                    var simplified = SimplifyExpression(expression);
                    var indent = line.Substring(0, line.Length - trimmed.Length);
                    _outputLines.Add($"{indent}#if {simplified}");
                }
                // If evalResult is True or False, we don't output the #if
            }
            else if (trimmed.StartsWith("#elif ") || trimmed.StartsWith("#elif("))
            {
                if (state.Count == 0)
                {
                    throw new InvalidOperationException($"Unexpected #elif at line {i + 1}");
                }

                var current = state.Peek();
                var expression = ExtractExpression(trimmed, "#elif");
                var evalResult = EvaluateExpression(expression);

                // Handle elif: if previous branches were true/taken, skip this one
                if (current.EvalResult == TriState.True || current.BranchTaken && current.EvalResult == TriState.Unknown)
                {
                    // Previous branch was taken, this elif becomes else-false
                    current.BranchTaken = false;
                    if (current.EvalResult == TriState.Unknown)
                    {
                        var simplified = SimplifyExpression(expression);
                        var indent = line.Substring(0, line.Length - trimmed.Length);
                        _outputLines.Add($"{indent}#elif {simplified}");
                    }
                }
                else if (current.EvalResult == TriState.False)
                {
                    // Previous branch was not taken, check this one
                    current.EvalResult = evalResult;
                    current.BranchTaken = evalResult == TriState.True || evalResult == TriState.Unknown;

                    if (evalResult == TriState.Unknown)
                    {
                        var simplified = SimplifyExpression(expression);
                        var indent = line.Substring(0, line.Length - trimmed.Length);
                        _outputLines.Add($"{indent}#elif {simplified}");
                    }
                }
                else
                {
                    // Unknown state - keep the elif
                    var simplified = SimplifyExpression(expression);
                    var indent = line.Substring(0, line.Length - trimmed.Length);
                    _outputLines.Add($"{indent}#elif {simplified}");
                    current.BranchTaken = evalResult == TriState.True || evalResult == TriState.Unknown;
                }
            }
            else if (trimmed == "#else")
            {
                if (state.Count == 0)
                {
                    throw new InvalidOperationException($"Unexpected #else at line {i + 1}");
                }

                var current = state.Peek();
                current.HasElse = true;

                if (current.EvalResult == TriState.True)
                {
                    // If was true, else is false - don't take this branch
                    current.ElseEvalResult = TriState.False;
                    current.BranchTaken = false;
                }
                else if (current.EvalResult == TriState.False)
                {
                    // If was false, else is true - take this branch
                    current.ElseEvalResult = TriState.True;
                    current.BranchTaken = true;
                }
                else
                {
                    // Unknown - keep the else
                    current.ElseEvalResult = TriState.Unknown;
                    current.BranchTaken = true;
                    _outputLines.Add(line);
                }
            }
            else if (trimmed == "#endif")
            {
                if (state.Count == 0)
                {
                    throw new InvalidOperationException($"Unexpected #endif at line {i + 1}");
                }

                var current = state.Pop();

                // Only output #endif if we had an unknown condition
                if (current.EvalResult == TriState.Unknown ||
                    (current.HasElse && current.ElseEvalResult == TriState.Unknown))
                {
                    _outputLines.Add(line);
                }
            }
            else
            {
                // Regular line - check if we should include it
                var shouldInclude = true;
                foreach (var s in state)
                {
                    if (!s.BranchTaken)
                    {
                        shouldInclude = false;
                        break;
                    }
                }

                if (shouldInclude)
                {
                    _outputLines.Add(line);
                }
            }

            i++;
        }

        return string.Join("\n", _outputLines);
    }

    static string ExtractExpression(string line, string directive)
    {
        var startIndex = line.IndexOf(directive, StringComparison.Ordinal) + directive.Length;
        return line.Substring(startIndex).Trim();
    }

    /// <summary>
    /// Evaluates a preprocessor expression.
    /// Returns True if the condition is definitely true, False if definitely false, Unknown if it depends on unknown symbols.
    /// </summary>
    TriState EvaluateExpression(string expression)
    {
        var parser = new ExpressionParser(expression, _definedSymbols, Splitter.AllKnownFrameworkSymbols);
        return parser.Evaluate();
    }

    /// <summary>
    /// Simplifies an expression by replacing known symbols with their values and simplifying boolean logic.
    /// </summary>
    string SimplifyExpression(string expression)
    {
        var parser = new ExpressionParser(expression, _definedSymbols, Splitter.AllKnownFrameworkSymbols);
        return parser.Simplify();
    }

    class ConditionalState
    {
        public required string OriginalExpression { get; init; }
        public TriState EvalResult { get; set; }
        public required string SimplifiedExpression { get; init; }
        public bool BranchTaken { get; set; }
        public bool HasElse { get; set; }
        public TriState? ElseEvalResult { get; set; }
        public int Line { get; init; }
    }
}

/// <summary>
/// Represents a tri-state boolean: True, False, or Unknown.
/// </summary>
public enum TriState
{
    False,
    True,
    Unknown
}

/// <summary>
/// Parses and evaluates preprocessor expressions, handling known and unknown symbols.
/// </summary>
public class ExpressionParser
{
    readonly string _expression;
    readonly HashSet<string> _definedSymbols;
    readonly HashSet<string> _knownSymbols;
    int _pos;

    public ExpressionParser(string expression, HashSet<string> definedSymbols, HashSet<string> knownSymbols)
    {
        _expression = expression;
        _definedSymbols = definedSymbols;
        _knownSymbols = knownSymbols;
        _pos = 0;
    }

    public TriState Evaluate()
    {
        _pos = 0;
        return ParseOr();
    }

    public string Simplify()
    {
        _pos = 0;
        return SimplifyOr();
    }

    void SkipWhitespace()
    {
        while (_pos < _expression.Length && char.IsWhiteSpace(_expression[_pos]))
        {
            _pos++;
        }
    }

    TriState ParseOr()
    {
        var left = ParseAnd();
        SkipWhitespace();

        while (_pos < _expression.Length - 1 && _expression.Substring(_pos, 2) == "||")
        {
            _pos += 2;
            var right = ParseAnd();
            left = OrTriState(left, right);
        }

        return left;
    }

    TriState ParseAnd()
    {
        var left = ParseUnary();
        SkipWhitespace();

        while (_pos < _expression.Length - 1 && _expression.Substring(_pos, 2) == "&&")
        {
            _pos += 2;
            var right = ParseUnary();
            left = AndTriState(left, right);
        }

        return left;
    }

    TriState ParseUnary()
    {
        SkipWhitespace();

        if (_pos < _expression.Length && _expression[_pos] == '!')
        {
            _pos++;
            var inner = ParseUnary();
            return NotTriState(inner);
        }

        return ParsePrimary();
    }

    TriState ParsePrimary()
    {
        SkipWhitespace();

        if (_pos < _expression.Length && _expression[_pos] == '(')
        {
            _pos++;
            var result = ParseOr();
            SkipWhitespace();
            if (_pos < _expression.Length && _expression[_pos] == ')')
            {
                _pos++;
            }
            return result;
        }

        // Parse identifier
        var start = _pos;
        while (_pos < _expression.Length && (char.IsLetterOrDigit(_expression[_pos]) || _expression[_pos] == '_'))
        {
            _pos++;
        }

        var identifier = _expression.Substring(start, _pos - start);
        SkipWhitespace();

        if (string.Equals(identifier, "true", StringComparison.OrdinalIgnoreCase))
        {
            return TriState.True;
        }
        if (string.Equals(identifier, "false", StringComparison.OrdinalIgnoreCase))
        {
            return TriState.False;
        }

        // Check if this is a known symbol
        if (_knownSymbols.Contains(identifier))
        {
            return _definedSymbols.Contains(identifier) ? TriState.True : TriState.False;
        }

        // Unknown symbol
        return TriState.Unknown;
    }

    // Simplification methods
    string SimplifyOr()
    {
        var left = SimplifyAnd();
        SkipWhitespace();
        var parts = new List<string> { left };

        while (_pos < _expression.Length - 1 && _expression.Substring(_pos, 2) == "||")
        {
            _pos += 2;
            var right = SimplifyAnd();
            parts.Add(right);
        }

        // Simplify: if any part is "true", result is "true"
        // If any part is "false", remove it
        var filtered = parts.Where(p => p != "false").ToList();
        if (filtered.Any(p => p == "true"))
        {
            return "true";
        }
        if (filtered.Count == 0)
        {
            return "false";
        }
        if (filtered.Count == 1)
        {
            return filtered[0];
        }
        return string.Join(" || ", filtered);
    }

    string SimplifyAnd()
    {
        var left = SimplifyUnary();
        SkipWhitespace();
        var parts = new List<string> { left };

        while (_pos < _expression.Length - 1 && _expression.Substring(_pos, 2) == "&&")
        {
            _pos += 2;
            var right = SimplifyUnary();
            parts.Add(right);
        }

        // Simplify: if any part is "false", result is "false"
        // If any part is "true", remove it
        if (parts.Any(p => p == "false"))
        {
            return "false";
        }
        var filtered = parts.Where(p => p != "true").ToList();
        if (filtered.Count == 0)
        {
            return "true";
        }
        if (filtered.Count == 1)
        {
            return filtered[0];
        }
        return string.Join(" && ", filtered);
    }

    string SimplifyUnary()
    {
        SkipWhitespace();

        if (_pos < _expression.Length && _expression[_pos] == '!')
        {
            _pos++;
            var inner = SimplifyUnary();
            if (inner == "true")
            {
                return "false";
            }
            if (inner == "false")
            {
                return "true";
            }
            // Check if inner starts with ! and simplify double negation
            if (inner.StartsWith("!"))
            {
                return inner.Substring(1);
            }
            return $"!{inner}";
        }

        return SimplifyPrimary();
    }

    string SimplifyPrimary()
    {
        SkipWhitespace();

        if (_pos < _expression.Length && _expression[_pos] == '(')
        {
            _pos++;
            var result = SimplifyOr();
            SkipWhitespace();
            if (_pos < _expression.Length && _expression[_pos] == ')')
            {
                _pos++;
            }
            // Only keep parens if needed (contains || and was inside an && context)
            if (result.Contains("||") && !result.StartsWith("("))
            {
                return $"({result})";
            }
            return result;
        }

        // Parse identifier
        var start = _pos;
        while (_pos < _expression.Length && (char.IsLetterOrDigit(_expression[_pos]) || _expression[_pos] == '_'))
        {
            _pos++;
        }

        var identifier = _expression.Substring(start, _pos - start);
        SkipWhitespace();

        if (string.Equals(identifier, "true", StringComparison.OrdinalIgnoreCase))
        {
            return "true";
        }
        if (string.Equals(identifier, "false", StringComparison.OrdinalIgnoreCase))
        {
            return "false";
        }

        // Check if this is a known symbol - replace with true/false
        if (_knownSymbols.Contains(identifier))
        {
            return _definedSymbols.Contains(identifier) ? "true" : "false";
        }

        // Unknown symbol - keep as-is
        return identifier;
    }

    static TriState AndTriState(TriState left, TriState right)
    {
        if (left == TriState.False || right == TriState.False)
        {
            return TriState.False;
        }
        if (left == TriState.True && right == TriState.True)
        {
            return TriState.True;
        }
        return TriState.Unknown;
    }

    static TriState OrTriState(TriState left, TriState right)
    {
        if (left == TriState.True || right == TriState.True)
        {
            return TriState.True;
        }
        if (left == TriState.False && right == TriState.False)
        {
            return TriState.False;
        }
        return TriState.Unknown;
    }

    static TriState NotTriState(TriState value) =>
        value switch
        {
            TriState.True => TriState.False,
            TriState.False => TriState.True,
            _ => TriState.Unknown
        };
}
