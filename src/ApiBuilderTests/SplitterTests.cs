public class SplitterTests
{
    [Test]
#if RELEASE
    [Explicit]
#endif
    public Task Run() => Splitter.Run();

    [Test]
    public async Task ConvertPolyfill_NoEmptyConditionals()
    {
        // This tests the specific file that was reported as having empty conditionals
        var source = await File.ReadAllTextAsync(Path.Combine(Splitter.SplitOutputDir, "..", "Polyfill", "ConvertPolyfill.cs"));
        var definedSymbols = Splitter.GetPreprocessorSymbolsForFramework("net11.0");
        var resultLines = Splitter.ProcessFile(source, definedSymbols);
        resultLines = Splitter.RemoveEmptyConditionalBlocks(resultLines);
        resultLines = Splitter.RemoveEmptyLines(resultLines);

        // Should not have patterns like "#if X\n#endif" (empty conditional blocks)
        var lines = resultLines.Select(_ => _.TrimStart()).ToList();
        for (var i = 0; i < lines.Count - 1; i++)
        {
            var current = lines[i];
            var next = lines[i + 1];

            // Check for empty #if...#endif
            if ((current.StartsWith("#if ") || current.StartsWith("#if(")) && next == "#endif")
            {
                throw new($"Empty conditional block found: {current} followed by {next}");
            }

            // Check for empty #else...#endif
            if (current == "#else" && next == "#endif")
            {
                throw new($"Empty else block found: {current} followed by {next}");
            }
        }
    }

    [Test]
    public async Task RemoveEmptyLines_RemovesEmptyAndWhitespaceLines()
    {
        var source = """
            line1

            line2

            line3

            """;

        var sourceLines = source.Split('\n').Select(l => l.TrimEnd('\r')).ToList();
        var resultLines = Splitter.RemoveEmptyLines(sourceLines);
        var result = string.Join("\n", resultLines);

        await Assert.That(result).DoesNotContain("\n\n");
        await Assert.That(result).Contains("line1");
        await Assert.That(result).Contains("line2");
        await Assert.That(result).Contains("line3");

        // Should have exactly 3 lines
        await Assert.That(resultLines.Count).IsEqualTo(3);
    }

    [Test]
    public async Task RemoveEmptyConditionalBlocks_RemovesEmptyIfEndif()
    {
        var source = """
            // <auto-generated />
            #pragma warning disable
            #if !NET
            #endif
            #if !NET
            #endif
            #if FeatureMemory
            #if !NET
            #endif
            #endif
            #if !NET
            #endif
            """;

        var sourceLines = source.Split('\n').Select(l => l.TrimEnd('\r')).ToList();
        var resultLines = Splitter.RemoveEmptyConditionalBlocks(sourceLines);
        var result = string.Join("\n", resultLines);

        // Should remove all empty #if...#endif blocks, including nested ones
        await Assert.That(result).DoesNotContain("#if !NET");

        // #if FeatureMemory becomes empty after its nested block is removed, so it gets removed too
        await Assert.That(result).DoesNotContain("#if FeatureMemory");
        await Assert.That(result).DoesNotContain("#endif");

        // Count the remaining lines
        var nonEmptyLines = resultLines.Where(l => !string.IsNullOrWhiteSpace(l)).ToList();
        await Assert.That(nonEmptyLines.Count).IsEqualTo(2); // header, pragma
    }

    [Test]
    public async Task RemoveEmptyConditionalBlocks_PreservesNonEmptyBlock()
    {
        var source = """
            #if FeatureMemory
            actual_content
            #endif
            """;

        var sourceLines = source.Split('\n').Select(l => l.TrimEnd('\r')).ToList();
        var resultLines = Splitter.RemoveEmptyConditionalBlocks(sourceLines);
        var result = string.Join("\n", resultLines);

        // Non-empty blocks should be preserved
        await Assert.That(result).Contains("#if FeatureMemory");
        await Assert.That(result).Contains("actual_content");
        await Assert.That(result).Contains("#endif");
    }

    [Test]
    public async Task RemoveEmptyConditionalBlocks_RemovesEmptyElse()
    {
        var source = """
            #if FeatureMemory
            content
            #else
            #endif
            """;

        var sourceLines = source.Split('\n').Select(l => l.TrimEnd('\r')).ToList();
        var resultLines = Splitter.RemoveEmptyConditionalBlocks(sourceLines);
        var result = string.Join("\n", resultLines);

        await Assert.That(result).Contains("#if FeatureMemory");
        await Assert.That(result).Contains("content");
        await Assert.That(result).Contains("#endif");
        await Assert.That(result).DoesNotContain("#else");
    }

    [Test]
    public async Task RemoveEmptyConditionalBlocks_RemovesEmptyElif()
    {
        var source = """
            #if SomeCondition
            content1
            #elif EmptyCondition
            #else
            content2
            #endif
            """;

        var sourceLines = source.Split('\n').Select(l => l.TrimEnd('\r')).ToList();
        var resultLines = Splitter.RemoveEmptyConditionalBlocks(sourceLines);
        var result = string.Join("\n", resultLines);

        await Assert.That(result).Contains("#if SomeCondition");
        await Assert.That(result).Contains("content1");
        await Assert.That(result).Contains("#else");
        await Assert.That(result).Contains("content2");
        await Assert.That(result).Contains("#endif");
        await Assert.That(result).DoesNotContain("#elif");
    }

    [Test]
    public async Task SimpleIfTrue_RemovesDirective()
    {
        var source = """
            before
            #if NET5_0_OR_GREATER
            inside
            #endif
            after
            """;

        var definedSymbols = Splitter.GetPreprocessorSymbolsForFramework("net6.0");
        var result = string.Join("\n", Splitter.ProcessFile(source, definedSymbols));

        await Assert.That(result).DoesNotContain("#if");
        await Assert.That(result).DoesNotContain("#endif");
        await Assert.That(result).Contains("inside");
        await Assert.That(result).Contains("before");
        await Assert.That(result).Contains("after");
    }

    [Test]
    public async Task SimpleIfFalse_RemovesContent()
    {
        var source = """
            before
            #if NET8_0_OR_GREATER
            inside
            #endif
            after
            """;

        var definedSymbols = Splitter.GetPreprocessorSymbolsForFramework("net6.0");
        var result = string.Join("\n", Splitter.ProcessFile(source, definedSymbols));

        await Assert.That(result).DoesNotContain("#if");
        await Assert.That(result).DoesNotContain("#endif");
        await Assert.That(result).DoesNotContain("inside");
        await Assert.That(result).Contains("before");
        await Assert.That(result).Contains("after");
    }

    [Test]
    public async Task UnknownSymbol_PreservedInOutput()
    {
        var source = """
            #if FeatureMemory
            inside
            #endif
            """;

        var definedSymbols = Splitter.GetPreprocessorSymbolsForFramework("net6.0");
        var result = string.Join("\n", Splitter.ProcessFile(source, definedSymbols));

        await Assert.That(result).Contains("#if FeatureMemory");
        await Assert.That(result).Contains("#endif");
        await Assert.That(result).Contains("inside");
    }

    [Test]
    public async Task MixedCondition_SimplifiesExpression()
    {
        // FeatureMemory && !NET6_0_OR_GREATER
        // For net5.0: NET6_0_OR_GREATER is false, so !false = true, result is FeatureMemory && true = FeatureMemory
        var source = """
            #if FeatureMemory && !NET6_0_OR_GREATER
            inside
            #endif
            """;

        var definedSymbols = Splitter.GetPreprocessorSymbolsForFramework("net5.0");
        var result = string.Join("\n", Splitter.ProcessFile(source, definedSymbols));

        await Assert.That(result).Contains("#if FeatureMemory");
        await Assert.That(result).DoesNotContain("NET6_0_OR_GREATER");
        await Assert.That(result).Contains("#endif");
    }

    [Test]
    public async Task MixedCondition_WhenFrameworkTrue_BecomesSimpler()
    {
        // FeatureMemory && NET5_0_OR_GREATER
        // For net6.0: NET5_0_OR_GREATER is true, so result is FeatureMemory && true = FeatureMemory
        var source = """
            #if FeatureMemory && NET5_0_OR_GREATER
            inside
            #endif
            """;

        var definedSymbols = Splitter.GetPreprocessorSymbolsForFramework("net6.0");
        var result = string.Join("\n", Splitter.ProcessFile(source, definedSymbols));

        await Assert.That(result).Contains("#if FeatureMemory");
        await Assert.That(result).DoesNotContain("NET5_0_OR_GREATER");
    }

    [Test]
    public async Task MixedCondition_WhenFrameworkFalse_EvaluatesToFalse()
    {
        // FeatureMemory && NET8_0_OR_GREATER
        // For net6.0: NET8_0_OR_GREATER is false, so result is FeatureMemory && false = false
        var source = """
            #if FeatureMemory && NET8_0_OR_GREATER
            inside
            #endif
            """;

        var definedSymbols = Splitter.GetPreprocessorSymbolsForFramework("net6.0");
        var result = string.Join("\n", Splitter.ProcessFile(source, definedSymbols));

        await Assert.That(result).DoesNotContain("#if");
        await Assert.That(result).DoesNotContain("inside");
    }

    [Test]
    public async Task OrCondition_WhenFrameworkTrue_IncludesContent()
    {
        // FeatureMemory || NET5_0_OR_GREATER
        // For net6.0: NET5_0_OR_GREATER is true, so result is true
        var source = """
            #if FeatureMemory || NET5_0_OR_GREATER
            inside
            #endif
            """;

        var definedSymbols = Splitter.GetPreprocessorSymbolsForFramework("net6.0");
        var result = string.Join("\n", Splitter.ProcessFile(source, definedSymbols));

        await Assert.That(result).DoesNotContain("#if");
        await Assert.That(result).Contains("inside");
    }

    [Test]
    public async Task OrCondition_WhenFrameworkFalse_KeepsUnknown()
    {
        // FeatureMemory || NET8_0_OR_GREATER
        // For net6.0: NET8_0_OR_GREATER is false, so result is FeatureMemory || false = FeatureMemory
        var source = """
            #if FeatureMemory || NET8_0_OR_GREATER
            inside
            #endif
            """;

        var definedSymbols = Splitter.GetPreprocessorSymbolsForFramework("net6.0");
        var result = string.Join("\n", Splitter.ProcessFile(source, definedSymbols));

        await Assert.That(result).Contains("#if FeatureMemory");
        await Assert.That(result).DoesNotContain("NET8_0_OR_GREATER");
    }

    [Test]
    public async Task IfElse_WhenTrue_IncludesIfBranch()
    {
        var source = """
            #if NET5_0_OR_GREATER
            ifbranch
            #else
            elsebranch
            #endif
            """;

        var definedSymbols = Splitter.GetPreprocessorSymbolsForFramework("net6.0");
        var result = string.Join("\n", Splitter.ProcessFile(source, definedSymbols));

        await Assert.That(result).Contains("ifbranch");
        await Assert.That(result).DoesNotContain("elsebranch");
        await Assert.That(result).DoesNotContain("#if");
        await Assert.That(result).DoesNotContain("#else");
    }

    [Test]
    public async Task IfElse_WhenFalse_IncludesElseBranch()
    {
        var source = """
            #if NET8_0_OR_GREATER
            ifbranch
            #else
            elsebranch
            #endif
            """;

        var definedSymbols = Splitter.GetPreprocessorSymbolsForFramework("net6.0");
        var result = string.Join("\n", Splitter.ProcessFile(source, definedSymbols));

        await Assert.That(result).DoesNotContain("ifbranch");
        await Assert.That(result).Contains("elsebranch");
        await Assert.That(result).DoesNotContain("#if");
        await Assert.That(result).DoesNotContain("#else");
    }

    [Test]
    public async Task IfElse_WhenUnknown_KeepsBoth()
    {
        var source = """
            #if FeatureMemory
            ifbranch
            #else
            elsebranch
            #endif
            """;

        var definedSymbols = Splitter.GetPreprocessorSymbolsForFramework("net6.0");
        var result = string.Join("\n", Splitter.ProcessFile(source, definedSymbols));

        await Assert.That(result).Contains("ifbranch");
        await Assert.That(result).Contains("elsebranch");
        await Assert.That(result).Contains("#if FeatureMemory");
        await Assert.That(result).Contains("#else");
        await Assert.That(result).Contains("#endif");
    }

    [Test]
    public async Task Netcoreapp2x_DefinedForNetcoreapp2_0()
    {
        var symbols = Splitter.GetPreprocessorSymbolsForFramework("netcoreapp2.0");

        await Assert.That(symbols.Contains("NETCOREAPP2X")).IsTrue();
        await Assert.That(symbols.Contains("NETCOREAPP2_0")).IsTrue();
        await Assert.That(symbols.Contains("NETCOREAPP")).IsTrue();
    }

    [Test]
    public async Task Netcoreapp2x_DefinedForNetcoreapp2_1()
    {
        var symbols = Splitter.GetPreprocessorSymbolsForFramework("netcoreapp2.1");

        await Assert.That(symbols.Contains("NETCOREAPP2X")).IsTrue();
        await Assert.That(symbols.Contains("NETCOREAPP2_1")).IsTrue();
        await Assert.That(symbols.Contains("NETCOREAPP")).IsTrue();
    }

    [Test]
    public async Task Netcoreapp2x_DefinedForNetcoreapp2_2()
    {
        var symbols = Splitter.GetPreprocessorSymbolsForFramework("netcoreapp2.2");

        await Assert.That(symbols.Contains("NETCOREAPP2X")).IsTrue();
        await Assert.That(symbols.Contains("NETCOREAPP2_2")).IsTrue();
        await Assert.That(symbols.Contains("NETCOREAPP")).IsTrue();
    }

    [Test]
    public async Task Netcoreapp3x_DefinedForNetcoreapp3_0()
    {
        var symbols = Splitter.GetPreprocessorSymbolsForFramework("netcoreapp3.0");

        await Assert.That(symbols.Contains("NETCOREAPP3X")).IsTrue();
        await Assert.That(symbols.Contains("NETCOREAPP3_0")).IsTrue();
        await Assert.That(symbols.Contains("NETCOREAPPX")).IsTrue();
    }

    [Test]
    public async Task Netcoreappx_DefinedForAllNetcoreapp()
    {
        var symbols20 = Splitter.GetPreprocessorSymbolsForFramework("netcoreapp2.0");
        var symbols31 = Splitter.GetPreprocessorSymbolsForFramework("netcoreapp3.1");

        await Assert.That(symbols20.Contains("NETCOREAPPX")).IsTrue();
        await Assert.That(symbols31.Contains("NETCOREAPPX")).IsTrue();
    }

    [Test]
    public async Task Net46x_DefinedOnlyForNet461And462()
    {
        var symbols461 = Splitter.GetPreprocessorSymbolsForFramework("net461");
        var symbols462 = Splitter.GetPreprocessorSymbolsForFramework("net462");
        var symbols47 = Splitter.GetPreprocessorSymbolsForFramework("net47");

        await Assert.That(symbols461.Contains("NET46X")).IsTrue();
        await Assert.That(symbols462.Contains("NET46X")).IsTrue();
        // net47 should NOT have NET46X - it has NET47X instead
        await Assert.That(symbols47.Contains("NET46X")).IsFalse();
        await Assert.That(symbols47.Contains("NET47X")).IsTrue();
    }

    [Test]
    public async Task Net47x_DefinedForNet47Family()
    {
        var symbols47 = Splitter.GetPreprocessorSymbolsForFramework("net47");
        var symbols471 = Splitter.GetPreprocessorSymbolsForFramework("net471");
        var symbols472 = Splitter.GetPreprocessorSymbolsForFramework("net472");

        await Assert.That(symbols47.Contains("NET47X")).IsTrue();
        await Assert.That(symbols471.Contains("NET47X")).IsTrue();
        await Assert.That(symbols472.Contains("NET47X")).IsTrue();
    }

    [Test]
    public async Task Net48x_DefinedForNet48Family()
    {
        var symbols48 = Splitter.GetPreprocessorSymbolsForFramework("net48");
        var symbols481 = Splitter.GetPreprocessorSymbolsForFramework("net481");

        await Assert.That(symbols48.Contains("NET48X")).IsTrue();
        await Assert.That(symbols481.Contains("NET48X")).IsTrue();
    }

    [Test]
    public async Task NoFrameworkMonikers_InSimplifiedExpression()
    {
        var source = """
            #if NETFRAMEWORK || NETSTANDARD2_0
            inside
            #endif
            """;

        var definedSymbolsNet6 = Splitter.GetPreprocessorSymbolsForFramework("net6.0");
        var resultNet6 = string.Join("\n", Splitter.ProcessFile(source, definedSymbolsNet6));

        // For net6.0, both are false, so content should be removed
        await Assert.That(resultNet6).DoesNotContain("NETFRAMEWORK");
        await Assert.That(resultNet6).DoesNotContain("NETSTANDARD");
        await Assert.That(resultNet6).DoesNotContain("inside");
    }

    [Test]
    public async Task NoFrameworkMonikers_InSimplifiedExpression_WithNetFramework()
    {
        var source = """
            #if NETFRAMEWORK || NETSTANDARD2_0
            inside
            #endif
            """;

        var definedSymbolsNet461 = Splitter.GetPreprocessorSymbolsForFramework("net461");
        var resultNet461 = string.Join("\n", Splitter.ProcessFile(source, definedSymbolsNet461));

        // For net461, NETFRAMEWORK is true, so content should be included without directives
        await Assert.That(resultNet461).DoesNotContain("#if");
        await Assert.That(resultNet461).Contains("inside");
    }

    [Test]
    public async Task NegatedCondition_EvaluatesCorrectly()
    {
        var source = """
            #if !NET6_0_OR_GREATER
            inside
            #endif
            """;

        var definedSymbolsNet5 = Splitter.GetPreprocessorSymbolsForFramework("net5.0");
        var definedSymbolsNet6 = Splitter.GetPreprocessorSymbolsForFramework("net6.0");

        var resultNet5 = string.Join("\n", Splitter.ProcessFile(source, definedSymbolsNet5));
        var resultNet6 = string.Join("\n", Splitter.ProcessFile(source, definedSymbolsNet6));

        // For net5.0, !NET6_0_OR_GREATER = !false = true, include content
        await Assert.That(resultNet5).Contains("inside");
        await Assert.That(resultNet5).DoesNotContain("#if");

        // For net6.0, !NET6_0_OR_GREATER = !true = false, exclude content
        await Assert.That(resultNet6).DoesNotContain("inside");
    }

    [Test]
    public async Task NegatedUnknown_PreservesNegation()
    {
        var source = """
            #if !FeatureMemory
            inside
            #endif
            """;

        var definedSymbols = Splitter.GetPreprocessorSymbolsForFramework("net6.0");
        var result = string.Join("\n", Splitter.ProcessFile(source, definedSymbols));

        await Assert.That(result).Contains("#if !FeatureMemory");
        await Assert.That(result).Contains("inside");
    }

    [Test]
    public async Task NestedConditions_HandleCorrectly()
    {
        var source = """
            #if NET5_0_OR_GREATER
            outer_if
            #if NET6_0_OR_GREATER
            inner_if
            #endif
            after_inner
            #endif
            """;

        var definedSymbolsNet5 = Splitter.GetPreprocessorSymbolsForFramework("net5.0");
        var resultNet5 = string.Join("\n", Splitter.ProcessFile(source, definedSymbolsNet5));

        await Assert.That(resultNet5).Contains("outer_if");
        await Assert.That(resultNet5).DoesNotContain("inner_if");
        await Assert.That(resultNet5).Contains("after_inner");
    }

    [Test]
    public async Task ComplexExpression_SimplifiesCorrectly()
    {
        // (FeatureMemory || NET5_0_OR_GREATER) && !NET8_0_OR_GREATER
        // For net6.0: (FeatureMemory || true) && !false = true && true = true
        var source = """
            #if (FeatureMemory || NET5_0_OR_GREATER) && !NET8_0_OR_GREATER
            inside
            #endif
            """;

        var definedSymbols = Splitter.GetPreprocessorSymbolsForFramework("net6.0");
        var result = string.Join("\n", Splitter.ProcessFile(source, definedSymbols));

        // Should include the content without directives since the whole expression is true
        await Assert.That(result).Contains("inside");
        await Assert.That(result).DoesNotContain("#if");
    }

    [Test]
    public async Task AllKnownSymbols_ContainsXSuffixed()
    {
        await Assert.That(Splitter.AllKnownFrameworkSymbols.Contains("NETCOREAPP2X")).IsTrue();
        await Assert.That(Splitter.AllKnownFrameworkSymbols.Contains("NETCOREAPP3X")).IsTrue();
        await Assert.That(Splitter.AllKnownFrameworkSymbols.Contains("NETCOREAPPX")).IsTrue();
        await Assert.That(Splitter.AllKnownFrameworkSymbols.Contains("NET46X")).IsTrue();
        await Assert.That(Splitter.AllKnownFrameworkSymbols.Contains("NET47X")).IsTrue();
        await Assert.That(Splitter.AllKnownFrameworkSymbols.Contains("NET48X")).IsTrue();
    }

    [Test]
    public async Task AllKnownSymbols_ContainsFrameworkCategories()
    {
        await Assert.That(Splitter.AllKnownFrameworkSymbols.Contains("NETFRAMEWORK")).IsTrue();
        await Assert.That(Splitter.AllKnownFrameworkSymbols.Contains("NETSTANDARD")).IsTrue();
        await Assert.That(Splitter.AllKnownFrameworkSymbols.Contains("NETCOREAPP")).IsTrue();
    }

    [Test]
    public async Task FeatureSymbols_NotInKnownSymbols()
    {
        await Assert.That(Splitter.AllKnownFrameworkSymbols.Contains("FeatureMemory")).IsFalse();
        await Assert.That(Splitter.AllKnownFrameworkSymbols.Contains("FeatureValueTuple")).IsFalse();
        await Assert.That(Splitter.AllKnownFrameworkSymbols.Contains("FeatureValueTask")).IsFalse();
        await Assert.That(Splitter.AllKnownFrameworkSymbols.Contains("FeatureHttp")).IsFalse();
        await Assert.That(Splitter.AllKnownFrameworkSymbols.Contains("FeatureCompression")).IsFalse();
        await Assert.That(Splitter.AllKnownFrameworkSymbols.Contains("PolyPublic")).IsFalse();
        await Assert.That(Splitter.AllKnownFrameworkSymbols.Contains("PolyEnsure")).IsFalse();
        await Assert.That(Splitter.AllKnownFrameworkSymbols.Contains("PolyUseEmbeddedAttribute")).IsFalse();
    }

    [Test]
    public async Task PolyConditions_PreservedInOutput()
    {
        var source = """
            #if PolyPublic
            public class Foo { }
            #endif
            #if PolyUseEmbeddedAttribute
            [Embedded]
            #endif
            internal class Bar { }
            """;

        var definedSymbols = Splitter.GetPreprocessorSymbolsForFramework("net6.0");
        var result = string.Join("\n", Splitter.ProcessFile(source, definedSymbols));

        // PolyPublic and PolyUseEmbeddedAttribute should be preserved as unknown conditions
        await Assert.That(result).Contains("#if PolyPublic");
        await Assert.That(result).Contains("#if PolyUseEmbeddedAttribute");
        await Assert.That(result).Contains("public class Foo { }");
        await Assert.That(result).Contains("[Embedded]");
        await Assert.That(result).Contains("internal class Bar { }");
    }

    [Test]
    public async Task StringBuilder_Append_ProducesValidCSharp()
    {
        // This tests the specific file that was reported as producing invalid C#
        var source = await File.ReadAllTextAsync(Path.Combine(Splitter.SplitOutputDir, "..", "Polyfill", "StringInterpolation", "Polyfill_StringBuilder_Append.cs"));
        var definedSymbols = Splitter.GetPreprocessorSymbolsForFramework("net461");
        var resultLines = Splitter.ProcessFile(source, definedSymbols);
        resultLines = Splitter.RemoveEmptyConditionalBlocks(resultLines);
        resultLines = Splitter.RemoveEmptyLines(resultLines);
        var result = string.Join("\n", resultLines);

        // Must have matching braces and directives
        var openBraces = result.Count(c => c == '{');
        var closeBraces = result.Count(c => c == '}');
        await Assert.That(openBraces).IsEqualTo(closeBraces);

        var ifCount = Regex.Matches(result, @"#if\s").Count;
        var endifCount = Regex.Matches(result, "#endif").Count;
        await Assert.That(ifCount).IsEqualTo(endifCount);

        // Should not have #elif (NET6_0_OR_GREATER is false for net461)
        await Assert.That(result).DoesNotContain("#elif");
    }

    [Test]
    public async Task IfUnknown_ElifFalse_ProducesValidOutput()
    {
        // When #if has unknown condition and #elif has false condition,
        // the output should have #if and #endif but not #elif
        var source = """
            static partial class Polyfill
            {
            #if FeatureMemory && !NET6_0_OR_GREATER
                void Method1() { }
            #elif NET6_0_OR_GREATER
                void Method2() { }
            #endif
            }
            """;

        var definedSymbols = Splitter.GetPreprocessorSymbolsForFramework("net461");
        var result = string.Join("\n", Splitter.ProcessFile(source, definedSymbols));

        // Should have simplified #if FeatureMemory (since !NET6_0_OR_GREATER is true for net461)
        await Assert.That(result).Contains("#if FeatureMemory");
        await Assert.That(result).Contains("Method1");
        await Assert.That(result).Contains("#endif");
        await Assert.That(result).Contains("}"); // closing brace

        // Should NOT have #elif (since NET6_0_OR_GREATER is false for net461)
        await Assert.That(result).DoesNotContain("#elif");
        await Assert.That(result).DoesNotContain("Method2");
    }

    [Test]
    public async Task PolyConditions_NotRemovedByEmptyBlockRemoval()
    {
        // Ensure that empty block removal doesn't incorrectly remove Poly* conditions
        var source = """
            #if PolyPublic
            content
            #endif
            """;

        var sourceLines = source.Split('\n').Select(l => l.TrimEnd('\r')).ToList();
        var resultLines = Splitter.RemoveEmptyConditionalBlocks(sourceLines);
        var result = string.Join("\n", resultLines);

        // Should NOT be removed - it has content
        await Assert.That(result).Contains("#if PolyPublic");
        await Assert.That(result).Contains("content");
        await Assert.That(result).Contains("#endif");
    }

    [Test]
    public async Task OutputFiles_ContainNoFrameworkMonikers()
    {
        // Test that after processing, no framework monikers remain in any condition
        var source = """
            #if NETCOREAPP2X || NET47X
            code1
            #endif
            #if NETSTANDARD
            code2
            #endif
            #if NETFRAMEWORK
            code3
            #endif
            """;

        foreach (var framework in Splitter.Frameworks)
        {
            var symbols = Splitter.GetPreprocessorSymbolsForFramework(framework);
            var result = string.Join("\n", Splitter.ProcessFile(source, symbols));

            // Should never contain these framework symbols in the output
            await Assert.That(result).DoesNotContain("NETCOREAPP2X");
            await Assert.That(result).DoesNotContain("NET47X");
            await Assert.That(result).DoesNotContain("NETSTANDARD");
            await Assert.That(result).DoesNotContain("NETFRAMEWORK");
        }
    }

    [Test]
    public async Task XSuffixedSymbol_EvaluatesCorrectly()
    {
        var source = """
            #if NETCOREAPP2X
            inside
            #endif
            """;

        var symbolsNet20 = Splitter.GetPreprocessorSymbolsForFramework("netcoreapp2.0");
        var symbolsNet21 = Splitter.GetPreprocessorSymbolsForFramework("netcoreapp2.1");
        var symbolsNet22 = Splitter.GetPreprocessorSymbolsForFramework("netcoreapp2.2");
        var symbolsNet30 = Splitter.GetPreprocessorSymbolsForFramework("netcoreapp3.0");
        var symbolsNet60 = Splitter.GetPreprocessorSymbolsForFramework("net6.0");

        var resultNet20 = string.Join("\n", Splitter.ProcessFile(source, symbolsNet20));
        var resultNet21 = string.Join("\n", Splitter.ProcessFile(source, symbolsNet21));
        var resultNet22 = string.Join("\n", Splitter.ProcessFile(source, symbolsNet22));
        var resultNet30 = string.Join("\n", Splitter.ProcessFile(source, symbolsNet30));
        var resultNet60 = string.Join("\n", Splitter.ProcessFile(source, symbolsNet60));

        // NETCOREAPP2X should be true for netcoreapp2.0, 2.1, and 2.2
        await Assert.That(resultNet20).Contains("inside");
        await Assert.That(resultNet21).Contains("inside");
        await Assert.That(resultNet22).Contains("inside");

        // NETCOREAPP2X should be false for netcoreapp3.0 and net6.0
        await Assert.That(resultNet30).DoesNotContain("inside");
        await Assert.That(resultNet60).DoesNotContain("inside");
    }

    [Test]
    public async Task PreservesIndentation()
    {
        var source = """
                #if FeatureMemory
                    inside
                #endif
            """;

        var definedSymbols = Splitter.GetPreprocessorSymbolsForFramework("net6.0");
        var result = string.Join("\n", Splitter.ProcessFile(source, definedSymbols));

        await Assert.That(result).Contains("    #if FeatureMemory");
        await Assert.That(result).Contains("        inside");
    }

    [Test]
    public async Task Net5Plus_DefinesLegacyNetcoreappSymbols()
    {
        // .NET 5+ should define legacy NETCOREAPP symbols for backwards compatibility
        var symbolsNet5 = Splitter.GetPreprocessorSymbolsForFramework("net5.0");
        var symbolsNet6 = Splitter.GetPreprocessorSymbolsForFramework("net6.0");
        var symbolsNet7 = Splitter.GetPreprocessorSymbolsForFramework("net7.0");

        // All should have NETCOREAPP3_0_OR_GREATER
        await Assert.That(symbolsNet5.Contains("NETCOREAPP3_0_OR_GREATER")).IsTrue();
        await Assert.That(symbolsNet6.Contains("NETCOREAPP3_0_OR_GREATER")).IsTrue();
        await Assert.That(symbolsNet7.Contains("NETCOREAPP3_0_OR_GREATER")).IsTrue();

        // And also NETCOREAPP3_1_OR_GREATER
        await Assert.That(symbolsNet5.Contains("NETCOREAPP3_1_OR_GREATER")).IsTrue();
        await Assert.That(symbolsNet6.Contains("NETCOREAPP3_1_OR_GREATER")).IsTrue();
        await Assert.That(symbolsNet7.Contains("NETCOREAPP3_1_OR_GREATER")).IsTrue();

        // And NETCOREAPP
        await Assert.That(symbolsNet5.Contains("NETCOREAPP")).IsTrue();
        await Assert.That(symbolsNet6.Contains("NETCOREAPP")).IsTrue();
        await Assert.That(symbolsNet7.Contains("NETCOREAPP")).IsTrue();
    }

    [Test]
    public async Task NotNullAttributePattern_UsesTypeForwardForNet5Plus()
    {
        // This pattern is used in nullable attributes - define class for older frameworks,
        // use TypeForwardedTo for newer frameworks
        var source = """
            #if !NETCOREAPP3_0_OR_GREATER && !NETSTANDARD2_1_OR_GREATER
            class NotNullAttribute : Attribute { }
            #else
            [assembly: System.Runtime.CompilerServices.TypeForwardedTo(typeof(NotNullAttribute))]
            #endif
            """;

        // For net5.0+, NETCOREAPP3_0_OR_GREATER is true, so we should get the TypeForwardedTo branch
        var definedSymbolsNet5 = Splitter.GetPreprocessorSymbolsForFramework("net5.0");
        var resultNet5 = string.Join("\n", Splitter.ProcessFile(source, definedSymbolsNet5));

        await Assert.That(resultNet5).Contains("TypeForwardedTo");
        await Assert.That(resultNet5).DoesNotContain("class NotNullAttribute");

        // For net461, both conditions are false, so we get the class definition
        var definedSymbolsNet461 = Splitter.GetPreprocessorSymbolsForFramework("net461");
        var resultNet461 = string.Join("\n", Splitter.ProcessFile(source, definedSymbolsNet461));

        await Assert.That(resultNet461).Contains("class NotNullAttribute");
        await Assert.That(resultNet461).DoesNotContain("TypeForwardedTo");

        // For netstandard2.1, NETSTANDARD2_1_OR_GREATER is true, so we get TypeForwardedTo
        var definedSymbolsNs21 = Splitter.GetPreprocessorSymbolsForFramework("netstandard2.1");
        var resultNs21 = string.Join("\n", Splitter.ProcessFile(source, definedSymbolsNs21));

        await Assert.That(resultNs21).Contains("TypeForwardedTo");
        await Assert.That(resultNs21).DoesNotContain("class NotNullAttribute");
    }

    [Test]
    public async Task FileCompletelyExcluded_HasMinimalOutput()
    {
        // If the entire file content is excluded, we should get just the header
        var source = """
            // <auto-generated />
            #pragma warning disable

            #if NET8_0_OR_GREATER
            class NewFeature { }
            #endif
            """;

        var definedSymbolsNet6 = Splitter.GetPreprocessorSymbolsForFramework("net6.0");
        var resultNet6 = string.Join("\n", Splitter.ProcessFile(source, definedSymbolsNet6));

        await Assert.That(resultNet6).DoesNotContain("class NewFeature");
        await Assert.That(resultNet6).Contains("// <auto-generated />");
    }

    [Test]
    public async Task IndexRangePattern_ExcludedForNet5Plus()
    {
        // Index and Range types are defined in the framework for .NET 5+
        var source = """
            #if !NET5_0_OR_GREATER
            struct Index { }
            struct Range { }
            #endif
            """;

        var definedSymbolsNet5 = Splitter.GetPreprocessorSymbolsForFramework("net5.0");
        var resultNet5 = string.Join("\n", Splitter.ProcessFile(source, definedSymbolsNet5));

        await Assert.That(resultNet5).DoesNotContain("struct Index");
        await Assert.That(resultNet5).DoesNotContain("struct Range");

        var definedSymbolsNet461 = Splitter.GetPreprocessorSymbolsForFramework("net461");
        var resultNet461 = string.Join("\n", Splitter.ProcessFile(source, definedSymbolsNet461));

        await Assert.That(resultNet461).Contains("struct Index");
        await Assert.That(resultNet461).Contains("struct Range");
    }

    [Test]
    public async Task PolyfillMethodPattern_ExcludedWhenFrameworkHasIt()
    {
        // Methods like Append should be excluded when the framework has them
        var source = """
            #if !NET471_OR_GREATER && !NETSTANDARD2_0_OR_GREATER && !NETCOREAPP2_0_OR_GREATER
            static IEnumerable<T> Append<T>(this IEnumerable<T> source, T element) { }
            #endif
            """;

        // For net471+, this should be excluded
        var definedSymbolsNet471 = Splitter.GetPreprocessorSymbolsForFramework("net471");
        var resultNet471 = string.Join("\n", Splitter.ProcessFile(source, definedSymbolsNet471));
        await Assert.That(resultNet471).DoesNotContain("Append");

        // For net6.0 (which has NETCOREAPP2_0_OR_GREATER), this should be excluded
        var definedSymbolsNet6 = Splitter.GetPreprocessorSymbolsForFramework("net6.0");
        var resultNet6 = string.Join("\n", Splitter.ProcessFile(source, definedSymbolsNet6));
        await Assert.That(resultNet6).DoesNotContain("Append");

        // For net461, this should be included
        var definedSymbolsNet461 = Splitter.GetPreprocessorSymbolsForFramework("net461");
        var resultNet461 = string.Join("\n", Splitter.ProcessFile(source, definedSymbolsNet461));
        await Assert.That(resultNet461).Contains("Append");
    }

    [Test]
    public async Task XSuffixed_OnlyForSpecificFamily()
    {
        // NET46X should only be true for net461/net462, not net47+
        var source = """
            #if NET46X || NET47
            inside
            #endif
            """;

        // net461 - NET46X is true
        var result461 = string.Join("\n", Splitter.ProcessFile(source, Splitter.GetPreprocessorSymbolsForFramework("net461")));
        await Assert.That(result461).Contains("inside");

        // net462 - NET46X is true
        var result462 = string.Join("\n", Splitter.ProcessFile(source, Splitter.GetPreprocessorSymbolsForFramework("net462")));
        await Assert.That(result462).Contains("inside");

        // net47 - NET47 is true
        var result47 = string.Join("\n", Splitter.ProcessFile(source, Splitter.GetPreprocessorSymbolsForFramework("net47")));
        await Assert.That(result47).Contains("inside");

        // net471 - neither NET46X nor NET47 is true (NET47X is true but that's different)
        var result471 = string.Join("\n", Splitter.ProcessFile(source, Splitter.GetPreprocessorSymbolsForFramework("net471")));
        await Assert.That(result471).DoesNotContain("inside");

        // net472 - neither NET46X nor NET47 is true
        var result472 = string.Join("\n", Splitter.ProcessFile(source, Splitter.GetPreprocessorSymbolsForFramework("net472")));
        await Assert.That(result472).DoesNotContain("inside");

        // net48 - neither NET46X nor NET47 is true (NET48X is true but that's different)
        var result48 = string.Join("\n", Splitter.ProcessFile(source, Splitter.GetPreprocessorSymbolsForFramework("net48")));
        await Assert.That(result48).DoesNotContain("inside");
    }

    [Test]
    public async Task GetPreprocessorSymbols()
    {
        var dictionary = new Dictionary<string, HashSet<string>>();
        foreach (var framework in Splitter.Frameworks)
        {
            dictionary[framework] = Splitter.GetPreprocessorSymbolsForFramework(framework);
        }

        await Verify(dictionary);
    }

    [Test]
    public async Task WindowsUwp()
    {
        var source = """
            #if WINDOWS_UWP
            uwp_code
            #endif
            #if NETSTANDARD2_0
            netstandard_code
            #endif
            """;

        var symbolsUwp = Splitter.GetPreprocessorSymbolsForFramework("uap10.0");
        var resultUwp = string.Join("\n", Splitter.ProcessFile(source, symbolsUwp));

        // Both conditions should be true for WINDOWS_UWP
        await Assert.That(resultUwp).Contains("uwp_code");
        await Assert.That(resultUwp).Contains("netstandard_code");
        await Assert.That(resultUwp).DoesNotContain("#if");
    }

    [Test]
    public async Task NetSymbol_DefinedForNet5Plus()
    {
        // NET symbol should be defined for .NET 5+
        var symbolsNet5 = Splitter.GetPreprocessorSymbolsForFramework("net5.0");
        var symbolsNet6 = Splitter.GetPreprocessorSymbolsForFramework("net6.0");
        var symbolsNet10 = Splitter.GetPreprocessorSymbolsForFramework("net10.0");
        var symbolsNet11 = Splitter.GetPreprocessorSymbolsForFramework("net11.0");

        await Assert.That(symbolsNet5.Contains("NET")).IsTrue();
        await Assert.That(symbolsNet6.Contains("NET")).IsTrue();
        await Assert.That(symbolsNet10.Contains("NET")).IsTrue();
        await Assert.That(symbolsNet11.Contains("NET")).IsTrue();
    }

    [Test]
    public async Task NetSymbol_NotDefinedForNetFramework()
    {
        // NET symbol should NOT be defined for .NET Framework
        var symbolsNet461 = Splitter.GetPreprocessorSymbolsForFramework("net461");
        var symbolsNet48 = Splitter.GetPreprocessorSymbolsForFramework("net48");

        await Assert.That(symbolsNet461.Contains("NET")).IsFalse();
        await Assert.That(symbolsNet48.Contains("NET")).IsFalse();
    }

    [Test]
    public async Task NetSymbol_NotDefinedForNetCoreApp()
    {
        // NET symbol should NOT be defined for .NET Core (pre-.NET 5)
        var symbolsNetCoreApp21 = Splitter.GetPreprocessorSymbolsForFramework("netcoreapp2.1");
        var symbolsNetCoreApp31 = Splitter.GetPreprocessorSymbolsForFramework("netcoreapp3.1");

        await Assert.That(symbolsNetCoreApp21.Contains("NET")).IsFalse();
        await Assert.That(symbolsNetCoreApp31.Contains("NET")).IsFalse();
    }

    [Test]
    public async Task NotNetConditional_EvaluatedForNet5Plus()
    {
        // #if !NET should be false for .NET 5+, so content inside is excluded
        var source = """
            #if !NET
            class_definition
            #else
            type_forward
            #endif
            """;

        var symbolsNet10 = Splitter.GetPreprocessorSymbolsForFramework("net10.0");
        var result = string.Join("\n", Splitter.ProcessFile(source, symbolsNet10));

        await Assert.That(result).DoesNotContain("class_definition");
        await Assert.That(result).Contains("type_forward");
        await Assert.That(result).DoesNotContain("#if");
        await Assert.That(result).DoesNotContain("#else");
    }

    [Test]
    public async Task NotNetConditional_EvaluatedForNetFramework()
    {
        // #if !NET should be true for .NET Framework, so content inside is included
        var source = """
            #if !NET
            class_definition
            #else
            type_forward
            #endif
            """;

        var symbolsNet461 = Splitter.GetPreprocessorSymbolsForFramework("net461");
        var result = string.Join("\n", Splitter.ProcessFile(source, symbolsNet461));

        await Assert.That(result).Contains("class_definition");
        await Assert.That(result).DoesNotContain("type_forward");
        await Assert.That(result).DoesNotContain("#if");
        await Assert.That(result).DoesNotContain("#else");
    }

    [Test]
    public async Task TypeForwardedToExtraction_RemovesFromOriginalLines()
    {
        // When TypeForwardedTo is extracted, it should be removed from the lines
        var source = """
            namespace Test;
            class MyClass { }
            [assembly: System.Runtime.CompilerServices.TypeForwardedTo(typeof(System.String))]
            """;

        var lines = source.Split('\n').Select(l => l.TrimEnd('\r')).ToList();
        var forwardedToLines = lines.Where(l => l.TrimStart().Contains("TypeForwardedTo")).ToList();
        var remainingLines = lines.Where(l => !l.TrimStart().Contains("TypeForwardedTo")).ToList();

        await Assert.That(forwardedToLines.Count).IsEqualTo(1);
        await Assert.That(forwardedToLines[0]).Contains("TypeForwardedTo");
        await Assert.That(remainingLines.Count).IsEqualTo(2);
        await Assert.That(string.Join("\n", remainingLines)).DoesNotContain("TypeForwardedTo");
    }

    [Test]
    public async Task TypeForwardedToExtraction_HandlesMultipleAttributes()
    {
        // Multiple TypeForwardedTo attributes should all be extracted
        var source = """
            [assembly: System.Runtime.CompilerServices.TypeForwardedTo(typeof(System.String))]
            [assembly: System.Runtime.CompilerServices.TypeForwardedTo(typeof(System.Int32))]
            [assembly: System.Runtime.CompilerServices.TypeForwardedTo(typeof(System.Boolean))]
            """;

        var lines = source.Split('\n').Select(l => l.TrimEnd('\r')).ToList();
        var forwardedToLines = lines.Where(l => l.TrimStart().Contains("TypeForwardedTo")).ToList();

        await Assert.That(forwardedToLines.Count).IsEqualTo(3);
        await Assert.That(forwardedToLines[0]).Contains("String");
        await Assert.That(forwardedToLines[1]).Contains("Int32");
        await Assert.That(forwardedToLines[2]).Contains("Boolean");
    }

    [Test]
    public async Task ContainsTypes_DoesNotIncludeTypeForwardedTo()
    {
        // ContainsTypes should return false if only TypeForwardedTo is present
        var linesWithOnlyTypeForwardedTo = new List<string>
        {
            "[assembly: System.Runtime.CompilerServices.TypeForwardedTo(typeof(System.String))]"
        };

        var linesWithClass = new List<string>
        {
            "class MyClass { }"
        };

        var linesWithBoth = new List<string>
        {
            "class MyClass { }",
            "[assembly: System.Runtime.CompilerServices.TypeForwardedTo(typeof(System.String))]"
        };

        await Assert.That(Splitter.ContainsTypes(linesWithOnlyTypeForwardedTo)).IsFalse();
        await Assert.That(Splitter.ContainsTypes(linesWithClass)).IsTrue();
        await Assert.That(Splitter.ContainsTypes(linesWithBoth)).IsTrue();
    }

    [Test]
    public async Task IsExternalInit_Net10_ExtractedToTypeForwardeds()
    {
        // For .NET 10, IsExternalInit should only have TypeForwardedTo (extracted to TypeForwardeds.cs)
        var isExternalInitPath = Path.Combine(Splitter.SplitOutputDir, "net10.0", "IsExternalInit.cs");
        var typeForwardedsPath = Path.Combine(Splitter.SplitOutputDir, "net10.0", "TypeForwardeds.cs");

        // IsExternalInit.cs should NOT exist for net10.0
        await Assert.That(File.Exists(isExternalInitPath)).IsFalse();

        // TypeForwardeds.cs should exist and contain IsExternalInit
        await Assert.That(File.Exists(typeForwardedsPath)).IsTrue();
        var typeForwardedsContent = await File.ReadAllTextAsync(typeForwardedsPath);
        await Assert.That(typeForwardedsContent).Contains("IsExternalInit");
        await Assert.That(typeForwardedsContent).Contains("using System.Runtime.CompilerServices;");
    }

    [Test]
    public async Task IsExternalInit_Net461_HasClassDefinition()
    {
        // For .NET Framework 4.6.1, IsExternalInit should have the class definition (not TypeForwardedTo)
        var isExternalInitPath = Path.Combine(Splitter.SplitOutputDir, "net461", "IsExternalInit.cs");
        var typeForwardedsPath = Path.Combine(Splitter.SplitOutputDir, "net461", "TypeForwardeds.cs");

        // IsExternalInit.cs should exist with class definition
        await Assert.That(File.Exists(isExternalInitPath)).IsTrue();
        var isExternalInitContent = await File.ReadAllTextAsync(isExternalInitPath);
        await Assert.That(isExternalInitContent).Contains("static class IsExternalInit");
        await Assert.That(isExternalInitContent).DoesNotContain("TypeForwardedTo");

        // TypeForwardeds.cs should NOT exist for net461
        await Assert.That(File.Exists(typeForwardedsPath)).IsFalse();
    }

    [Test]
    public async Task TypeForwardeds_HasSimplifiedAttributeName()
    {
        // TypeForwardeds.cs should use simplified attribute name (TypeForwardedTo instead of System.Runtime.CompilerServices.TypeForwardedTo)
        var typeForwardedsPath = Path.Combine(Splitter.SplitOutputDir, "net10.0", "TypeForwardeds.cs");

        await Assert.That(File.Exists(typeForwardedsPath)).IsTrue();
        var content = await File.ReadAllTextAsync(typeForwardedsPath);

        // Should have using statement
        await Assert.That(content).Contains("using System.Runtime.CompilerServices;");

        // Should use simplified form
        await Assert.That(content).Contains("[assembly: TypeForwardedTo(typeof(");

        // Should NOT have the full namespace prefix for the attribute
        var lines = content.Split('\n');
        var assemblyLines = lines.Where(l => l.Contains("[assembly:")).ToList();
        foreach (var line in assemblyLines)
        {
            await Assert.That(line).DoesNotContain("System.Runtime.CompilerServices.TypeForwardedTo");
        }
    }

    [Test]
    public async Task TypeForwardeds_CountsByFramework()
    {
        // Verify that different frameworks have different numbers of TypeForwardedTo attributes
        var net10Path = Path.Combine(Splitter.SplitOutputDir, "net10.0", "TypeForwardeds.cs");
        var net5Path = Path.Combine(Splitter.SplitOutputDir, "net5.0", "TypeForwardeds.cs");

        if (File.Exists(net10Path) && File.Exists(net5Path))
        {
            var net10Content = await File.ReadAllTextAsync(net10Path);
            var net5Content = await File.ReadAllTextAsync(net5Path);

            var net10Count = net10Content.Split('\n').Count(_ => _.Contains("TypeForwardedTo"));
            var net5Count = net5Content.Split('\n').Count(_ => _.Contains("TypeForwardedTo"));

            // .NET 10 should have more TypeForwardedTo than .NET 5
            await Assert.That(net10Count).IsGreaterThan(net5Count);
        }
    }

    [Test]
    public async Task NoTypeForwardedTo_InNonTypeForwardedsFiles()
    {
        // Verify that no files except TypeForwardeds.cs contain TypeForwardedTo
        var net10Dir = Path.Combine(Splitter.SplitOutputDir, "net10.0");

        if (Directory.Exists(net10Dir))
        {
            var csFiles = Directory.GetFiles(net10Dir, "*.cs", SearchOption.AllDirectories)
                .Where(_ => Path.GetFileName(_) != "TypeForwardeds.cs")
                .ToList();

            foreach (var file in csFiles)
            {
                var content = await File.ReadAllTextAsync(file);
                if (content.Contains("TypeForwardedTo"))
                {
                    throw new($"File {Path.GetFileName(file)} should not contain TypeForwardedTo");
                }
            }
        }
    }

    [Test]
    public async Task IsOnlyTypeForwardedTo_WithOnlyTypeForwardedTo_ReturnsTrue()
    {
        var lines = new List<string>
        {
            "[assembly: System.Runtime.CompilerServices.TypeForwardedTo(typeof(System.Runtime.CompilerServices.CallerArgumentExpressionAttribute))]"
        };

        var result = Splitter.IsOnlyTypeForwardedTo(lines);

        await Assert.That(result).IsTrue();
    }

    [Test]
    public async Task IsOnlyTypeForwardedTo_WithTypeDefinition_ReturnsFalse()
    {
        var lines = new List<string>
        {
            "#if !NET",
            "class CallerArgumentExpressionAttribute : Attribute { }",
            "#else",
            "[assembly: System.Runtime.CompilerServices.TypeForwardedTo(typeof(System.Runtime.CompilerServices.CallerArgumentExpressionAttribute))]",
            "#endif"
        };

        var result = Splitter.IsOnlyTypeForwardedTo(lines);

        await Assert.That(result).IsFalse();
    }

    [Test]
    public async Task IsOnlyTypeForwardedTo_WithNoTypeForwardedTo_ReturnsFalse()
    {
        var lines = new List<string>
        {
            "namespace System.Runtime.CompilerServices;",
            "class SomeClass { }"
        };

        var result = Splitter.IsOnlyTypeForwardedTo(lines);

        await Assert.That(result).IsFalse();
    }

    [Test]
    public async Task IsOnlyTypeForwardedTo_WithEmptyLines_ReturnsTrue()
    {
        var lines = new List<string>
        {
            "",
            "[assembly: System.Runtime.CompilerServices.TypeForwardedTo(typeof(System.Runtime.CompilerServices.CallerArgumentExpressionAttribute))]",
            ""
        };

        var result = Splitter.IsOnlyTypeForwardedTo(lines);

        await Assert.That(result).IsTrue();
    }
}
