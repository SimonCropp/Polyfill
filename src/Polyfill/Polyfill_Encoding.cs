// <auto-generated />

using System.Runtime.InteropServices;
using System.Text;

#pragma warning disable

#if FeatureMemory

namespace Polyfills;

using System;

static partial class Polyfill
{
#if NETCOREAPP2_0 || NETFRAMEWORK || NETSTANDARD2_0
    /// <summary>
    /// When overridden in a derived class, calculates the number of bytes produced by encoding the characters in the specified character span.
    /// </summary>
    /// <param name="encoding"></param>
    /// <param name="chars">The span of characters to encode.</param>
    /// <returns>The number of bytes produced by encoding the specified character span.</returns>
    //Link: https://learn.microsoft.com/en-us/dotnet/api/system.text.encoding.getbytecount#system-text-encoding-getbytecount(system-readonlyspan((system-char)))
#if AllowUnsafeBlocks
    public unsafe static int GetByteCount(this Encoding target, ReadOnlySpan<char> chars)
    {
        if (target is null)
        {
            throw new ArgumentNullException(nameof(target));
        }

        fixed (char* charsPtr = chars)
        {
            return target.GetByteCount(charsPtr, chars.Length);
        }
    }
#else
    public static int GetByteCount(this Encoding target, ReadOnlySpan<char> chars)
    {
        if (target is null)
        {
            throw new ArgumentNullException(nameof(target));
        }

        return target.GetByteCount(chars.ToArray());
    }
#endif
#endif

#if !NETCOREAPP2_1_OR_GREATER
    /// <summary>When overridden in a derived class, encodes into a span of bytes a set of characters from the specified read-only span.</summary>
    /// <param name="chars">The span containing the set of characters to encode.</param>
    /// <param name="bytes">The byte span to hold the encoded bytes.</param>
    /// <returns>The number of encoded bytes.</returns>
    //Link: https://learn.microsoft.com/en-us/dotnet/api/system.text.encoding.getbytes#system-text-encoding-getbytes(system-readonlyspan((system-char))-system-span((system-byte)))
#if AllowUnsafeBlocks
    public static unsafe int GetBytes(this Encoding target, ReadOnlySpan<char> chars, Span<byte> bytes)
    {
        if (target is null)
        {
            throw new ArgumentNullException(nameof(target));
        }

        fixed (char* charsPtr = chars)
        fixed (byte* bytesPtr = bytes)
        {
            return target.GetBytes(charsPtr, chars.Length, bytesPtr, bytes.Length);
        }
    }
#else
    public static int GetBytes(this Encoding target, ReadOnlySpan<char> chars, Span<byte> bytes)
    {
        if (target is null)
        {
            throw new ArgumentNullException(nameof(target));
        }

        var result = target.GetBytes(chars.ToArray());
        result.CopyTo(bytes);
        return result.Length;
    }
#endif
#endif
#if !NETCOREAPP2_1_OR_GREATER
    /// <summary>When overridden in a derived class, decodes all the bytes in the specified byte span into a string.</summary>
    /// <param name="bytes">A read-only byte span to decode to a Unicode string.</param>
    /// <returns>A string that contains the decoded bytes from the provided read-only span.</returns>
    //Link: https://learn.microsoft.com/en-us/dotnet/api/system.text.encoding.getstring#system-text-encoding-getstring(system-readonlyspan((system-byte)))
#if AllowUnsafeBlocks
    public static unsafe string GetString(this Encoding target, ReadOnlySpan<byte> bytes)
    {
        if (target is null)
        {
            throw new ArgumentNullException(nameof(target));
        }

        fixed (byte* bytesPtr = bytes)
        {
            return target.GetString(bytesPtr, bytes.Length);
        }
    }
#else
    public static string GetString(this Encoding target, ReadOnlySpan<byte> bytes)
    {
        if (target is null)
        {
            throw new ArgumentNullException(nameof(target));
        }

        return target.GetString(bytes.ToArray());
    }
#endif
#endif

#if !NET8_0_OR_GREATER

    /// <summary>Decodes into a span of chars a set of bytes from the specified read-only span if the destination is large enough.</summary>
    /// <param name="bytes">A read-only span containing the sequence of bytes to decode.</param>
    /// <param name="chars">The character span receiving the decoded bytes.</param>
    /// <param name="charsWritten">Upon successful completion of the operation, the number of chars decoded into <paramref name="chars"/>.</param>
    /// <returns><see langword="true"/> if all of the characters were decoded into the destination; <see langword="false"/> if the destination was too small to contain all the decoded chars.</returns>
    ///Link: https://learn.microsoft.com/en-us/dotnet/api/system.text.encoding.trygetchars
    public static bool TryGetChars(this Encoding target, ReadOnlySpan<byte> bytes, Span<char> chars, out int charsWritten)
    {
        int required = target.GetCharCount(bytes);
        if (required <= chars.Length)
        {
            charsWritten = target.GetChars(bytes, chars);
            return true;
        }

        charsWritten = 0;
        return false;
    }
    /// <summary>Encodes into a span of bytes a set of characters from the specified read-only span if the destination is large enough.</summary>
    /// <param name="chars">The span containing the set of characters to encode.</param>
    /// <param name="bytes">The byte span to hold the encoded bytes.</param>
    /// <param name="bytesWritten">Upon successful completion of the operation, the number of bytes encoded into <paramref name="bytes"/>.</param>
    /// <returns><see langword="true"/> if all of the characters were encoded into the destination; <see langword="false"/> if the destination was too small to contain all the encoded bytes.</returns>
    ///Link: https://learn.microsoft.com/en-us/dotnet/api/system.text.encoding.trygetbytes
    public static bool TryGetBytes(this Encoding target, ReadOnlySpan<char> chars, Span<byte> bytes, out int bytesWritten)
    {
        int required = target.GetByteCount(chars);
        if (required <= bytes.Length)
        {
            bytesWritten = target.GetBytes(chars, bytes);
            return true;
        }

        bytesWritten = 0;
        return false;
    }
#endif
}

#endif