// <auto-generated />
#pragma warning disable

#if !NET6_0_OR_GREATER

namespace Polyfills;

using System;
using System.Threading;
using System.Threading.Tasks;

static partial class Polyfill
{
    const uint MaxSupportedTimeout = 0xfffffffe;

    /// <summary>Gets a <see cref="Task"/> that will complete when this <see cref="Task"/> completes or when the specified <see cref="CancellationToken"/> has cancellation requested.</summary>
    //Link: https://learn.microsoft.com/en-us/dotnet/api/system.threading.tasks.task.waitasync?view=net-10.0#system-threading-tasks-task-waitasync(system-threading-cancellationtoken)
    public static Task WaitAsync(this Task target, CancellationToken cancellationToken) =>
        target.WaitAsync(Timeout.InfiniteTimeSpan, cancellationToken);

    /// <summary>Gets a <see cref="Task"/> that will complete when this <see cref="Task"/> completes or when the specified timeout expires.</summary>
    //Link: https://learn.microsoft.com/en-us/dotnet/api/system.threading.tasks.task.waitasync?view=net-10.0#system-threading-tasks-task-waitasync(system-timespan)
    public static Task WaitAsync(
        this Task target,
        TimeSpan timeout) =>
        target.WaitAsync(timeout, default);

    /// <summary>Gets a <see cref="Task"/> that will complete when this <see cref="Task"/> completes, when the specified timeout expires, or when the specified <see cref="CancellationToken"/> has cancellation requested.</summary>
    //Link: https://learn.microsoft.com/en-us/dotnet/api/system.threading.tasks.task.waitasync?view=net-10.0#system-threading-tasks-task-waitasync(system-timespan-system-threading-cancellationtoken)
    public static Task WaitAsync(
        this Task target,
        TimeSpan timeout,
        CancellationToken cancellationToken)
    {
        var milliseconds = (long) timeout.TotalMilliseconds;
        if (milliseconds is < -1 or > MaxSupportedTimeout)
        {
            throw new ArgumentOutOfRangeException(nameof(timeout));
        }

        if (target.IsCompleted ||
            (!cancellationToken.CanBeCanceled && timeout == Timeout.InfiniteTimeSpan))
        {
            return target;
        }

        if (cancellationToken.IsCancellationRequested)
        {
            return Task.FromCanceled(cancellationToken);
        }

        if (timeout == TimeSpan.Zero)
        {
            return Task.FromException(new TimeoutException());
        }

        return WaitAsyncCore(target, timeout, cancellationToken);
    }

    static async Task WaitAsyncCore(Task task, TimeSpan timeout, CancellationToken cancelToken)
    {
        using var timeoutCancelSource = CreateTimeoutCancelSource(timeout, cancelToken, out var combinedToken);
        var cancelSource = new TaskCompletionSource<bool>();

        // Register for cancellation/timeout
        using (combinedToken.Register(() => cancelSource.TrySetCanceled(combinedToken), useSynchronizationContext: false))
        {
            var completedTask = await Task.WhenAny(task, cancelSource.Task).ConfigureAwait(false);

            if (completedTask == task)
            {
                // Original task completed - propagate result/exception
                await task.ConfigureAwait(false);
                return;
            }

            // Check if it was a timeout or cancellation
            if (timeoutCancelSource != null &&
                timeoutCancelSource.IsCancellationRequested &&
                !cancelToken.IsCancellationRequested)
            {
                throw new TimeoutException();
            }

            // Propagate cancellation
            await cancelSource.Task.ConfigureAwait(false);
        }
    }

    static CancellationTokenSource CreateTimeoutCancelSource(
        TimeSpan timeout,
        CancellationToken cancelToken,
        out CancellationToken combinedToken)
    {
        if (timeout == Timeout.InfiniteTimeSpan)
        {
            // No timeout - just use the provided cancellation token
            combinedToken = cancelToken;
            return null;
        }

        if (!cancelToken.CanBeCanceled)
        {
            // Only timeout matters
            var cancelSource = new CancellationTokenSource(timeout);
            combinedToken = cancelSource.Token;
            return cancelSource;
        }

        // Both timeout and cancellation token matter - combine them
        var timeoutCancelSource = CancellationTokenSource.CreateLinkedTokenSource(cancelToken);
        timeoutCancelSource.CancelAfter(timeout);
        combinedToken = timeoutCancelSource.Token;
        return timeoutCancelSource;
    }

    /// <summary>
    /// Gets a <see cref="Task"/> that will complete when this <see cref="Task"/> completes, or when the specified <see cref="CancellationToken"/> has cancellation requested.
    /// </summary>
    //Link: https://learn.microsoft.com/en-us/dotnet/api/system.threading.tasks.task.waitasync?view=net-10.0#system-threading-tasks-task-waitasync(system-threading-cancellationtoken)
    public static Task<TResult> WaitAsync<TResult>(
        this Task<TResult> target,
        CancellationToken cancellationToken) =>
        target.WaitAsync<TResult>(Timeout.InfiniteTimeSpan, cancellationToken);

    /// <summary>
    /// Gets a <see cref="Task"/> that will complete when this <see cref="Task"/> completes, or when the specified timeout expires.
    /// </summary>
    //Link: https://learn.microsoft.com/en-us/dotnet/api/system.threading.tasks.task-1.waitasync?view=net-10.0#system-threading-tasks-task-1-waitasync(system-timespan)
    public static Task<TResult> WaitAsync<TResult>(
        this Task<TResult> target,
        TimeSpan timeout) =>
        target.WaitAsync<TResult>(timeout, default);

    /// <summary>
    /// Gets a <see cref="Task"/> that will complete when this <see cref="Task"/> completes, when the specified timeout expires, or when the specified <see cref="CancellationToken"/> has cancellation requested.
    /// </summary>
    //Link: https://learn.microsoft.com/en-us/dotnet/api/system.threading.tasks.task-1.waitasync?view=net-10.0#system-threading-tasks-task-1-waitasync(system-timespan-system-threading-cancellationtoken)
    public static async Task<TResult> WaitAsync<TResult>(
        this Task<TResult> target,
        TimeSpan timeout,
        CancellationToken cancellationToken)
    {
        await ((Task) target).WaitAsync(timeout, cancellationToken);
        return target.Result;
    }
}

#endif
