// <auto-generated />
#pragma warning disable

namespace Polyfills;

using System;
using System.Text;
using System.IO;
using System.Runtime.CompilerServices;

static partial class Polyfill
{
#if FeatureMemory && !NET6_0_OR_GREATER

    /// <summary>
    /// Copies the contents of this string into the destination span.
    /// </summary>
    /// <param name="destination">The span into which to copy this string's contents</param>
    //Link: https://learn.microsoft.com/en-us/dotnet/api/system.string.copyto
    public static void CopyTo(this string target, Span<char> destination) =>
        target.AsSpan().CopyTo(destination);

    /// <summary>
    /// Copies the contents of this string into the destination span.
    /// </summary>
    /// <param name="destination">The span into which to copy this string's contents</param>
    /// <returns>true if the data was copied; false if the destination was too short to fit the contents of the string.</returns>
    //Link: https://learn.microsoft.com/en-us/dotnet/api/system.string.trycopyto
    public static bool TryCopyTo(this string target, Span<char> destination) =>
        target.AsSpan().TryCopyTo(destination);
#endif

#if FeatureMemory && !NET8_0_OR_GREATER && FeatureValueTuple
    /// <summary>Creates a new <see cref="ReadOnlySpan{Char}"/> over a portion of the target string from a specified position to the end of the string.</summary>
    /// <param name="text">The target string.</param>
    /// <param name="startIndex">The index at which to begin this slice.</param>
    /// <exception cref="ArgumentOutOfRangeException"><paramref name="startIndex"/> is less than 0 or greater than <paramref name="text"/>.Length.</exception>
    //Link: https://learn.microsoft.com/en-us/dotnet/api/system.memoryextensions.asspan#system-memoryextensions-asspan(system-string-system-range)
    public static ReadOnlySpan<char> AsSpan(this string? text, Index startIndex)
    {
        int actualIndex = startIndex.GetOffset(text == null ? 0 : text.Length);

        return MemoryExtensions.AsSpan(text, actualIndex);
    }

    /// <summary>Creates a new <see cref="ReadOnlySpan{Char}"/> over a portion of a target string using the range start and end indexes.</summary>
    /// <param name="text">The target string.</param>
    /// <param name="range">The range which has start and end indexes to use for slicing the string.</param>
    /// <exception cref="ArgumentNullException"><paramref name="text"/> is null.</exception>
    /// <exception cref="ArgumentOutOfRangeException"><paramref name="range"/>'s start or end index is not within the bounds of the string.</exception>
    /// <exception cref="ArgumentOutOfRangeException"><paramref name="range"/>'s start index is greater than its end index.</exception>
    //Link: https://learn.microsoft.com/en-us/dotnet/api/system.memoryextensions.asspan#system-memoryextensions-asspan(system-string-system-index)
    public static ReadOnlySpan<char> AsSpan(this string? text, Range range)
    {
        var tuple = range.GetOffsetAndLength(text == null ? 0 : text.Length);

        return text.AsSpan(tuple.Offset, tuple.Length);
    }
#endif

#if NETFRAMEWORK || NETSTANDARD2_0

    /// <summary>
    /// Returns the hash code for this string using the specified rules.
    /// </summary>
    /// <param name="comparisonType">One of the enumeration values that specifies the rules to use in the comparison.</param>
    /// <returns>A 32-bit signed integer hash code.</returns>
    //Link: https://learn.microsoft.com/en-us/dotnet/api/system.string.gethashcode#system-string-gethashcode(system-stringcomparison)
    public static int GetHashCode(this string target, StringComparison comparisonType) =>
        FromComparison(comparisonType).GetHashCode(target);

    static StringComparer FromComparison(StringComparison comparison) =>
        comparison switch
        {
            StringComparison.CurrentCulture => StringComparer.CurrentCulture,
            StringComparison.CurrentCultureIgnoreCase => StringComparer.CurrentCultureIgnoreCase,
            StringComparison.InvariantCulture => StringComparer.InvariantCulture,
            StringComparison.InvariantCultureIgnoreCase => StringComparer.InvariantCultureIgnoreCase,
            StringComparison.Ordinal => StringComparer.Ordinal,
            StringComparison.OrdinalIgnoreCase => StringComparer.OrdinalIgnoreCase,
            _ => throw new ArgumentOutOfRangeException(nameof(comparison), comparison, null)
        };

    /// <summary>
    /// Returns a value indicating whether a specified character occurs within this string, using the specified comparison rules.
    /// </summary>
    /// <param name="value">The character to seek.</param>
    /// <param name="comparisonType">One of the enumeration values that specifies the rules to use in the comparison.</param>
    /// <returns>true if the value parameter occurs within this string; otherwise, false.</returns>
    //Link: https://learn.microsoft.com/en-us/dotnet/api/system.string.contains#system-string-contains(system-char-system-stringcomparison)
    public static bool Contains(this string target, char value, StringComparison comparisonType) =>
        target.IndexOf(value, comparisonType) >= 0;

    /// <summary>
    /// Reports the zero-based index of the first occurrence of the specified Unicode character in this string. A parameter specifies the type of search to use for the specified character.
    /// </summary>
    /// <param name="value">The character to seek.</param>
    /// <param name="comparisonType">An enumeration value that specifies the rules for the search.</param>
    /// <returns>The zero-based index of value if that character is found, or -1 if it is not.</returns>
    //Link: https://learn.microsoft.com/en-us/dotnet/api/system.string.indexof#system-string-indexof(system-char-system-stringcomparison)
    public static int IndexOf(this string target, char value, StringComparison comparisonType) =>
        target.IndexOf(value.ToString(), comparisonType);

    /// <summary>
    /// Returns a value indicating whether a specified string occurs within this string, using the specified comparison rules.
    /// </summary>
    /// <param name="value">The string to seek.</param>
    /// <param name="comparisonType">One of the enumeration values that specifies the rules to use in the comparison.</param>
    /// <returns>true if the value parameter occurs within this string, or if value is the empty string (""); otherwise, false.</returns>
    //Link: https://learn.microsoft.com/en-us/dotnet/api/system.string.contains#system-string-contains(system-string-system-stringcomparison)
    public static bool Contains(this string target, string value, StringComparison comparisonType) =>
        target.IndexOf(value, comparisonType) >= 0;

    /// <summary>
    /// Determines whether this string instance starts with the specified character.
    /// </summary>
    /// <param name="value">The character to compare.</param>
    /// <returns>true if value matches the beginning of this string; otherwise, false.</returns>
    //Link: https://learn.microsoft.com/en-us/dotnet/api/system.string.startswith#system-string-startswith(system-char)
    public static bool StartsWith(this string target, char value)
    {
        if (target.Length == 0)
        {
            return false;
        }

        return target[0] == value;
    }

    /// <summary>
    /// Returns a value indicating whether a specified character occurs within this string.
    /// </summary>
    /// <param name="value">The character to seek.</param>
    /// <returns>true if the value parameter occurs within this string; otherwise, false.</returns>
    //Link: https://learn.microsoft.com/en-us/dotnet/api/system.string.endswith#system-string-endswith(system-char)
    public static bool EndsWith(this string target, char value)
    {
        if (target.Length == 0)
        {
            return false;
        }

        var lastPos = target.Length - 1;
        return target[lastPos] == value;
    }

    /// <summary>
    /// Splits a string into a maximum number of substrings based on a specified delimiting character and, optionally,
    /// options. Splits a string into a maximum number of substrings based on the provided character separator,
    /// optionally omitting empty substrings from the result.
    /// </summary>
    /// <param name="separator">A character that delimits the substrings in this instance.</param>
    /// <param name="options">A bitwise combination of the enumeration values that specifies whether to trim substrings
    /// and include empty substrings.</param>
    /// <returns>An array that contains at most count substrings from this instance that are delimited by separator.</returns>
    //Link: https://learn.microsoft.com/en-us/dotnet/api/system.string.split#system-string-split(system-char-system-stringsplitoptions)
    public static string[] Split(this string target, char separator, StringSplitOptions options = StringSplitOptions.None) =>
        target.Split([separator], options);

    /// <summary>
    /// Splits a string into a maximum number of substrings based on a specified delimiting character and, optionally,
    /// options. Splits a string into a maximum number of substrings based on the provided character separator,
    /// optionally omitting empty substrings from the result.
    /// </summary>
    /// <param name="separator">A character that delimits the substrings in this instance.</param>
    /// <param name="count">The maximum number of elements expected in the array.</param>
    /// <param name="options">A bitwise combination of the enumeration values that specifies whether to trim substrings
    /// and include empty substrings.</param>
    /// <returns>An array that contains at most count substrings from this instance that are delimited by separator.</returns>
    //Link: https://learn.microsoft.com/en-us/dotnet/api/system.string.split#system-string-split(system-char-system-int32-system-stringsplitoptions)
    public static string[] Split(this string target, char separator, int count, StringSplitOptions options = StringSplitOptions.None) =>
        target.Split([separator], count, options);
#endif

#if NETFRAMEWORK || NETSTANDARD2_0 || NETCOREAPP2_0
    /// <summary>
    /// Returns a value indicating whether a specified character occurs within this string.
    /// </summary>
    /// <returns>true if the value parameter occurs within this string; otherwise, false.</returns>
    //Link: https://learn.microsoft.com/en-us/dotnet/api/system.string.contains#system-string-contains(system-char)
    public static bool Contains(this string target, char value) =>
        target.IndexOf(value) >= 0;
#endif

#if !NET6_0_OR_GREATER
    /// <summary>
    /// Replaces all newline sequences in the current string with <paramref name="replacementText"/>.
    /// </summary>
    /// <returns>
    /// A string whose contents match the current string, but with all newline sequences replaced
    /// with <paramref name="replacementText"/>.
    /// </returns>
    //Link: https://learn.microsoft.com/en-us/dotnet/api/system.string.replacelineendings#system-string-replacelineendings(system-string)
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static string ReplaceLineEndings(this string target, string replacementText)
    {
        var builder = new StringBuilder();
        using var reader = new StringReader(target);
        while (true)
        {
            var line = reader.ReadLine();
            if (line == null)
            {
                break;
            }

            builder.Append(line);
            builder.Append(replacementText);
        }

        return builder.ToString(0, builder.Length - replacementText.Length);
    }

    /// <summary>
    /// Replaces all newline sequences in the current string with <see cref="Environment.NewLine"/>.
    /// </summary>
    /// <returns>
    /// A string whose contents match the current string, but with all newline sequences replaced
    /// with <see cref="Environment.NewLine"/>.
    /// </returns>
    //Link: https://learn.microsoft.com/en-us/dotnet/api/system.string.replacelineendings#system-string-replacelineendings
    public static string ReplaceLineEndings(this string target) =>
        ReplaceLineEndings(target, Environment.NewLine);
#endif
}