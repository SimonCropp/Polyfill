// <auto-generated />
#pragma warning disable
// Licensed to the .NET Foundation under one or more agreements.
// The .NET Foundation licenses this file to you under the MIT license.

#if !NET7_0_OR_GREATER && FeatureMemory

namespace System.Text.RegularExpressions;

using System;
using System.Collections.Concurrent;
using System.Collections.Generic;
using System.Diagnostics.CodeAnalysis;
using System.Diagnostics;
using System.Threading;

[ExcludeFromCodeCoverage]
[DebuggerNonUserCode]
#if PolyUseEmbeddedAttribute
[global::Microsoft.CodeAnalysis.EmbeddedAttribute]
#endif
// https://github.com/dotnet/runtime/blob/main/src/libraries/System.Text.RegularExpressions/src/System/Text/RegularExpressions/Regex.Cache.cs
/// <summary>Cache used to store Regex instances used by the static methods on Regex.</summary>
internal sealed class RegexCache
{
    const int DefaultMaxCacheSize = 15;
    const int MaxExamineOnDrop = 30;

    static volatile Node? s_lastAccessed;
    static ConcurrentDictionary<Key, Node> s_cacheDictionary = new ConcurrentDictionary<Key, Node>(concurrencyLevel: 1, capacity: 31);
    static List<Node> s_cacheList = new List<Node>(DefaultMaxCacheSize);
    static Random s_random = new Random();
    static int s_maxCacheSize = DefaultMaxCacheSize;

    static object SyncObj => s_cacheDictionary;

    /// <summary>Gets or sets the maximum size of the cache.</summary>
    public static int MaxCacheSize
    {
        get
        {
            lock (SyncObj)
            {
                return s_maxCacheSize;
            }
        }
        set
        {
            lock (SyncObj)
            {
                s_maxCacheSize = value;

                if (value == 0)
                {
                    s_cacheDictionary.Clear();
                    s_cacheList.Clear();
                    s_lastAccessed = null;
                }
                else if (value < s_cacheList.Count)
                {
                    s_lastAccessed = s_cacheList[0];
                    for (int i = value; i < s_cacheList.Count; i++)
                    {
                        s_cacheDictionary.TryRemove(s_cacheList[i].Key, out _);
                    }
                    s_cacheList.RemoveRange(value, s_cacheList.Count - value);
                }
            }
        }
    }

    public static Regex GetOrAdd(string pattern)
    {
        var key = new Key(pattern, RegexOptions.None, Regex.InfiniteMatchTimeout);

        var regex = Get(key);
        if (regex is null)
        {
            regex = new Regex(pattern);
            Add(key, regex);
        }

        return regex;
    }

    public static Regex GetOrAdd(string pattern, RegexOptions options, TimeSpan matchTimeout)
    {
        Key key = new Key(pattern, options, matchTimeout);

        Regex? regex = Get(key);
        if (regex is null)
        {
            regex = new Regex(pattern, options, matchTimeout);
            Add(key, regex);
        }

        return regex;
    }

    static Regex? Get(Key key)
    {
        long lastAccessedStamp = 0;

        if (s_lastAccessed is Node lastAccessed)
        {
            if (key.Equals(lastAccessed.Key))
            {
                return lastAccessed.Regex;
            }

            lastAccessedStamp = Volatile.Read(ref lastAccessed.LastAccessStamp);
        }

        if (s_maxCacheSize != 0 &&
            s_cacheDictionary.TryGetValue(key, out Node? node))
        {
            Volatile.Write(ref node.LastAccessStamp, lastAccessedStamp + 1);

            s_lastAccessed = node;

            return node.Regex;
        }

        return null;
    }

    static void Add(Key key, Regex regex)
    {
        lock (SyncObj)
        {
            if (s_maxCacheSize == 0 || s_cacheDictionary.TryGetValue(key, out _))
            {
                return;
            }

            if (s_cacheList.Count == s_maxCacheSize)
            {
                int itemsToExamine;
                bool useRandom;

                if (s_maxCacheSize <= MaxExamineOnDrop)
                {
                    itemsToExamine = s_cacheList.Count;
                    useRandom = false;
                }
                else
                {
                    itemsToExamine = MaxExamineOnDrop;
                    useRandom = true;
                }

                int minListIndex = useRandom ? s_random.Next(s_cacheList.Count) : 0;
                long min = Volatile.Read(ref s_cacheList[minListIndex].LastAccessStamp);

                for (int i = 1; i < itemsToExamine; i++)
                {
                    int nextIndex = useRandom ? s_random.Next(s_cacheList.Count) : i;
                    long next = Volatile.Read(ref s_cacheList[nextIndex].LastAccessStamp);
                    if (next < min)
                    {
                        minListIndex = nextIndex;
                        min = next;
                    }
                }

                s_cacheDictionary.TryRemove(s_cacheList[minListIndex].Key, out _);
                s_cacheList.RemoveAt(minListIndex);
            }

            var node = new Node(key, regex);
            s_lastAccessed = node;
            s_cacheList.Add(node);
            s_cacheDictionary.TryAdd(key, node);
        }
    }

    /// <summary>Used as a key for <see cref="Node"/>.</summary>
    internal readonly struct Key : IEquatable<Key>
    {
        readonly string _pattern;
        readonly RegexOptions _options;
        readonly TimeSpan _matchTimeout;

        public Key(string pattern, RegexOptions options, TimeSpan matchTimeout)
        {
            _pattern = pattern;
            _options = options;
            _matchTimeout = matchTimeout;
        }

        public override bool Equals([NotNullWhen(true)] object? obj) =>
            obj is Key other && Equals(other);

        public bool Equals(Key other) =>
            _pattern.Equals(other._pattern) &&
            _options == other._options &&
            _matchTimeout == other._matchTimeout;

        public override int GetHashCode() =>
            _pattern.GetHashCode() ^ (int)_options;
    }

    /// <summary>Node for a cached Regex instance.</summary>
    sealed class Node(Key key, Regex regex)
    {
        /// <summary>The key associated with this cached instance.</summary>
        public readonly Key Key = key;
        /// <summary>The cached Regex instance.</summary>
        public readonly Regex Regex = regex;
        /// <summary>A "time" stamp representing the approximate last access time for this Regex.</summary>
        public long LastAccessStamp;
    }
}
#endif