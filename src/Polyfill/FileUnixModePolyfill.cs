// <auto-generated />

#pragma warning disable

namespace Polyfills;

using System;
using System.IO;
using System.Diagnostics;
using System.Runtime.InteropServices;
using System.Runtime.Versioning;

static partial class FilePolyfill
{
    /// <summary>
    /// Gets the UnixFileMode of the file on the path.
    /// </summary>
    /// <param name="path">The path to the file.</param>
    /// <returns>The UnixFileMode of the file handle.</returns>
    //Link: https://learn.microsoft.com/en-us/dotnet/api/system.io.file.getunixfilemode?view=net-10.0#system-io-file-getunixfilemode(system-string)
    [UnsupportedOSPlatform("windows")]
    public static UnixFileMode GetUnixFileMode(string path) =>
#if NET7_0_OR_GREATER
        File.GetUnixFileMode(path);
#else
        GetUnixFileModeFallback(path);

    [UnsupportedOSPlatform("windows")]
    static UnixFileMode GetUnixFileModeFallback(string path)
    {
#if FeatureRuntimeInformation
        if (RuntimeInformation.IsOSPlatform(OSPlatform.Windows))
        {
            throw new PlatformNotSupportedException();
        }
#else
        if (Environment.OSVersion.Platform == PlatformID.Win32NT)
        {
            throw new PlatformNotSupportedException();
        }
#endif
        if (string.IsNullOrEmpty(path))
        {
            throw new ArgumentException("path is a zero-length string, or contains one or more invalid characters. Query for invalid characters by using the GetInvalidPathChars() method.");
        }

        var startInfo = new ProcessStartInfo()
        {
            FileName = "stat",
            Arguments = $"-c %a {Path.GetFullPath(path)}",
            RedirectStandardOutput = true,
            RedirectStandardInput = false,
            UseShellExecute = false,
            CreateNoWindow = true,
        };

        using var process = Process.Start(startInfo);

        process.WaitForExit();

        var output = process.StandardOutput.ReadToEnd();

        output = output.Length == 4 ? output : output.Insert(0, "0");

        UnixFileMode mode;

        // Digit 1 (out of 4) is for Special permissions
        switch (output[0])
        {
            case '1':
                mode = UnixFileMode.StickyBit;
                break;
            case '2':
                mode = UnixFileMode.SetUser;
                break;
            case '4':
                mode = UnixFileMode.SetGroup;
                break;
            default:
                mode = UnixFileMode.None;
                break;
        }

        // Digit 2 (out of 4) for Users
        switch (output[1])
        {
            case '0':
                mode = mode | UnixFileMode.None;
                break;
            case '1':
                mode = mode | UnixFileMode.UserExecute;
                break;
            case '2':
                mode = mode | UnixFileMode.UserWrite;
                break;
            case '3':
                mode = mode | UnixFileMode.UserExecute | UnixFileMode.UserWrite;
                break;
            case '4':
                mode = mode | UnixFileMode.UserRead;
                break;
            case '5':
                mode = mode | UnixFileMode.UserRead | UnixFileMode.UserExecute;
                break;
            case '6':
                mode = mode | UnixFileMode.UserRead | UnixFileMode.UserWrite;
                break;
            case '7':
                mode = mode | UnixFileMode.UserRead | UnixFileMode.UserWrite | UnixFileMode.UserExecute;
                break;
            default:
                throw new Exception("Invalid octal notation detected");
        }

        // Digit 3 (out of 4) for Groups
        switch (output[2])
        {
            case '0':
                mode = mode | UnixFileMode.None;
                break;
            case '1':
                mode = mode | UnixFileMode.GroupExecute;
                break;
            case '2':
                mode = mode | UnixFileMode.GroupWrite;
                break;
            case '3':
                mode = mode | UnixFileMode.GroupExecute | UnixFileMode.GroupWrite;
                break;
            case '4':
                mode = mode | UnixFileMode.GroupRead;
                break;
            case '5':
                mode = mode | UnixFileMode.GroupRead | UnixFileMode.GroupExecute;
                break;
            case '6':
                mode = mode | UnixFileMode.GroupRead | UnixFileMode.GroupWrite;
                break;
            case '7':
                mode = mode | UnixFileMode.GroupRead | UnixFileMode.GroupWrite | UnixFileMode.GroupExecute;
                break;
            default:
                throw new Exception("Invalid octal notation detected");
        }

        // Digit 4 (out of 4) for Others
        switch (output[3])
        {
            case '0':
                mode = mode | UnixFileMode.None;
                break;
            case '1':
                mode = mode | UnixFileMode.OtherExecute;
                break;
            case '2':
                mode = mode | UnixFileMode.OtherWrite;
                break;
            case '3':
                mode = mode | UnixFileMode.OtherExecute | UnixFileMode.OtherWrite;
                break;
            case '4':
                mode = mode | UnixFileMode.OtherRead;
                break;
            case '5':
                mode = mode | UnixFileMode.OtherRead | UnixFileMode.OtherExecute;
                break;
            case '6':
                mode = mode | UnixFileMode.OtherRead | UnixFileMode.OtherWrite;
                break;
            case '7':
                mode = mode | UnixFileMode.OtherRead | UnixFileMode.OtherWrite | UnixFileMode.OtherExecute;
                break;
            default:
                throw new Exception("Invalid octal notation detected");
        }

        return mode;
    }
#endif

    /// <summary>
    /// Sets the specified UnixFileMode of the file on the specified pat
    /// </summary>
    /// <param name="path">The path to the file.</param>
    /// <param name="unixFileMode">The Unix file mode.</param>
    //Link: https://learn.microsoft.com/en-us/dotnet/api/system.io.file.setunixfilemode?view=net-10.0#system-io-file-setunixfilemode(system-string-system-io-unixfilemode)
    [UnsupportedOSPlatform("windows")]
    public static void SetUnixFileMode(string path, UnixFileMode mode) =>
#if NET7_0_OR_GREATER
        File.SetUnixFileMode(path, mode);
#else
        SetUnixFileModeFallback(path, mode);

    [UnsupportedOSPlatform("windows")]
    static void SetUnixFileModeFallback(string path, UnixFileMode mode)
    {
#if FeatureRuntimeInformation
        if (RuntimeInformation.IsOSPlatform(OSPlatform.Windows))
        {
            throw new PlatformNotSupportedException();
        }
#else
        if (Environment.OSVersion.Platform == PlatformID.Win32NT)
        {
            throw new PlatformNotSupportedException();
        }
#endif
        if (string.IsNullOrEmpty(path))
        {
            throw new ArgumentException("path is a zero-length string, or contains one or more invalid characters. Query for invalid characters by using the GetInvalidPathChars() method.");
        }

        var octal = new int[4]
        {
            0,
            0,
            0,
            0
        };

        string[] fileModeStrings = mode.ToString()
            .Replace("UnixFileMode.", "")
            .Replace(",", string.Empty)
            .Replace(Environment.NewLine, string.Empty)
            .Split(' ');

        foreach (var fileModeString in fileModeStrings)
        {
            switch (fileModeString.ToLower())
            {
                //The digits are set to 0 by default, so we don't need to do anything.
                case "none":
                    break;
                case "userread":
                    octal[1] = octal[1] + 4;
                    break;
                case "userwrite":
                    octal[1] = octal[1] + 2;
                    break;
                case "userexecute":
                    octal[1] = octal[1] + 1;
                    break;
                case "groupread":
                    octal[2] = octal[2] + 4;
                    break;
                case "groupwrite":
                    octal[2] = octal[2] + 2;
                    break;
                case "groupexecute":
                    octal[2] = octal[2] + 1;
                    break;
                case "otherread":
                    octal[3] = octal[3] + 4;
                    break;
                case "otherwrite":
                    octal[3] = octal[3] + 2;
                    break;
                case "otherexecute":
                    octal[3] = octal[3] + 1;
                    break;
                case "setuser":
                    octal[0] = octal[0] + 2;
                    break;
                case "stickybit":
                    octal[0] = octal[0] + 1;
                    break;
                case "setgroup":
                    octal[0] = octal[0] + 4;
                    break;
                default:
                    throw new Exception("Invalid notation detected");
            }
        }

        var startInfo = new ProcessStartInfo()
        {
            FileName = "chmod",
            Arguments = $"{string.Concat(octal)} {Path.GetFullPath(path)}",
            RedirectStandardOutput = true,
            RedirectStandardInput = false,
            UseShellExecute = false,
            CreateNoWindow = true,
        };

        using var process = Process.Start(startInfo);
        process.WaitForExit();
    }
#endif
}