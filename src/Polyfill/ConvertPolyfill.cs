// <auto-generated />

#pragma warning disable

namespace Polyfills;

using System;
using System.Text;
using System.Diagnostics;
using System.Diagnostics.CodeAnalysis;

[ExcludeFromCodeCoverage]
[DebuggerNonUserCode]
#if PolyPublic
public
#endif
static partial class ConvertPolyfill
{
    /// <summary>
    /// Converts a subset of an array of 8-bit unsigned integers to its equivalent string representation that is encoded with uppercase hex characters.
    /// Parameters specify the subset as an offset in the input array and the number of elements in the array to convert.
    /// </summary>
    //Link: https://learn.microsoft.com/en-us/dotnet/api/system.convert.tohexstring?view=net-10.0#system-convert-tohexstring(system-byte()-system-int32-system-int32)
    public static string ToHexString(byte[] inArray, int offset, int length)
#if NET
        => Convert.ToHexString(inArray, offset, length);
#else
    {
        if (length < 0)
            throw new ArgumentOutOfRangeException(nameof(length));
        if (offset < 0)
            throw new ArgumentOutOfRangeException(nameof(offset));
        if (offset > (inArray.Length - length))
            throw new ArgumentOutOfRangeException(nameof(offset));

        var builder = new StringBuilder(length * 2);

        var end = length + offset;
        for (int i = offset; i < end; i++)
        {
            var item = inArray[i];
            builder.Append(item.ToString("X2"));
        }

        return builder.ToString();
    }
#endif

    /// <summary>
    /// Converts a subset of an array of 8-bit unsigned integers to its equivalent string representation that is encoded with lowercase hex characters.
    /// Parameters specify the subset as an offset in the input array and the number of elements in the array to convert.
    /// </summary>
    //Link: https://learn.microsoft.com/en-us/dotnet/api/system.convert.tohexstringlower?view=net-10.0#system-convert-tohexstringlower(system-byte()-system-int32-system-int32)
    public static string ToHexStringLower(byte[] inArray, int offset, int length)
#if NET9_0_OR_GREATER
        => Convert.ToHexStringLower(inArray, offset, length);
#else
    {
        if (length < 0)
            throw new ArgumentOutOfRangeException(nameof(length));
        if (offset < 0)
            throw new ArgumentOutOfRangeException(nameof(offset));
        if (offset > (inArray.Length - length))
            throw new ArgumentOutOfRangeException(nameof(offset));

        var builder = new StringBuilder(length * 2);

        var end = length + offset;
        for (int i = offset; i < end; i++)
        {
            var item = inArray[i];
            builder.Append(item.ToString("x2"));
        }

        return builder.ToString();
    }
#endif

    /// <summary>
    /// Converts an array of 8-bit unsigned integers to its equivalent string representation that is encoded with uppercase hex characters.
    /// </summary>
    //Link: https://learn.microsoft.com/en-us/dotnet/api/system.convert.tohexstring?view=net-10.0#system-convert-tohexstring(system-byte())
    public static string ToHexString(byte[] inArray) =>
#if NET
        Convert.ToHexString(inArray);
#else
        ConvertPolyfill.ToHexString(inArray, 0, inArray.Length);
#endif

    /// <summary>
    /// Converts an array of 8-bit unsigned integers to its equivalent string representation that is encoded with lowercase hex characters.
    /// </summary>
    //Link: https://learn.microsoft.com/en-us/dotnet/api/system.convert.tohexstringlower?view=net-10.0#system-convert-tohexstringlower(system-byte())
    public static string ToHexStringLower(byte[] inArray) =>
#if NET9_0_OR_GREATER
        Convert.ToHexStringLower(inArray);
#else
        ConvertPolyfill.ToHexStringLower(inArray, 0, inArray.Length);
#endif

#if FeatureMemory
    /// <summary>
    /// Converts a span of 8-bit unsigned integers to its equivalent string representation that is encoded with uppercase hex characters.
    /// </summary>
    //Link: https://learn.microsoft.com/en-us/dotnet/api/system.convert.tohexstring?view=net-10.0#system-convert-tohexstring(system-readonlyspan((system-byte)))
    public static string ToHexString(ReadOnlySpan<byte> bytes) =>
#if NET
        Convert.ToHexString(bytes);
#else
        ConvertPolyfill.ToHexString(bytes.ToArray());
#endif

    /// <summary>
    /// Converts a span of 8-bit unsigned integers to its equivalent string representation that is encoded with lowercase hex characters.
    /// </summary>
    //Link: https://learn.microsoft.com/en-us/dotnet/api/system.convert.tohexstringlower?view=net-10.0#system-convert-tohexstringlower(system-readonlyspan((system-byte)))
    public static string ToHexStringLower(ReadOnlySpan<byte> bytes) =>
#if NET9_0_OR_GREATER
        Convert.ToHexStringLower(bytes);
#else
        ConvertPolyfill.ToHexStringLower(bytes.ToArray());
#endif

    /// <summary>
    /// Converts a span of 8-bit unsigned integers to its equivalent span representation that is encoded with uppercase hex characters.
    /// </summary>
    //Link: https://learn.microsoft.com/en-us/dotnet/api/system.convert.trytohexstring?view=net-10.0
    public static bool TryToHexString(ReadOnlySpan<byte> source, Span<char> destination, out int charsWritten)
#if NET9_0_OR_GREATER
        => Convert.TryToHexString(source, destination, out charsWritten);
#else
    {
        if (source.Length > destination.Length / 2)
        {
            charsWritten = 0;
            return false;
        }

        var hexString = ConvertPolyfill.ToHexString(source);
        hexString.CopyTo(destination);
        charsWritten = hexString.Length;
        return true;
    }
#endif

    /// <summary>
    /// Converts a span of 8-bit unsigned integers to its equivalent span representation that is encoded with lowercase hex characters.
    /// </summary>
    //Link: https://learn.microsoft.com/en-us/dotnet/api/system.convert.trytohexstringlower?view=net-10.0
    public static bool TryToHexStringLower(ReadOnlySpan<byte> source, Span<char> destination, out int charsWritten)
#if NET9_0_OR_GREATER
        => Convert.TryToHexStringLower(source, destination, out charsWritten);
#else
    {
        if (source.Length > destination.Length / 2)
        {
            charsWritten = 0;
            return false;
        }

        var hexString = ConvertPolyfill.ToHexStringLower(source);
        hexString.CopyTo(destination);
        charsWritten = hexString.Length;
        return true;
    }
#endif


#endif

    /// <summary>
    /// Converts the specified string, which encodes binary data as hex characters, to an equivalent 8-bit unsigned integer array.
    /// </summary>
    //Link: https://learn.microsoft.com/en-us/dotnet/api/system.convert.fromhexstring?view=net-10.0#system-convert-fromhexstring(system-string)
    public static byte[] FromHexString(string hexString)
#if NET
        => Convert.FromHexString(hexString);
#else
    {
        if (hexString.Length % 2 != 0)
            throw new FormatException("Hex string must have an even length.");

        var result = new byte[hexString.Length / 2];

        for (int i = 0; i < result.Length; i++)
        {
            result[i] = (byte) ((GetHexValue(hexString[i * 2]) << 4) + GetHexValue(hexString[i * 2 + 1]));
        }

        return result;

        static int GetHexValue(char hex)
        {
            return hex switch
            {
                >= '0' and <= '9' => hex - '0',
                >= 'A' and <= 'F' => hex - 'A' + 10,
                >= 'a' and <= 'f' => hex - 'a' + 10,
                _ => throw new FormatException($"Invalid hex character: {hex}")
            };
        }
    }
#endif

#if FeatureMemory
    /// <summary>
    /// Converts the span, which encodes binary data as hex characters, to an equivalent 8-bit unsigned integer array.
    /// </summary>
    //Link: https://learn.microsoft.com/en-us/dotnet/api/system.convert.fromhexstring?view=net-10.0#system-convert-fromhexstring(system-readonlyspan((system-char)))
    public static byte[] FromHexString(ReadOnlySpan<char> chars)
#if NET
        => Convert.FromHexString(chars);
#else
        => ConvertPolyfill.FromHexString(chars.ToString());
#endif
#endif
}