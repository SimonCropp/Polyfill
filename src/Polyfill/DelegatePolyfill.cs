// <auto-generated />
#pragma warning disable

namespace Polyfills;

using System;
using System.ComponentModel;
using System.Diagnostics;
using System.Diagnostics.CodeAnalysis;
using System.Runtime.CompilerServices;

[ExcludeFromCodeCoverage]
[DebuggerNonUserCode]
#if PolyPublic
public
#endif
static partial class DelegatePolyfill
{
    /// <summary>
    /// Gets an enumerator for the invocation targets of this delegate.
    /// </summary>
    //Link: https://learn.microsoft.com/en-us/dotnet/api/system.delegate.enumerateinvocationlist?view=net-10.0
#if NET9_0_OR_GREATER
    public static Delegate.InvocationListEnumerator<TDelegate> EnumerateInvocationList<TDelegate>(TDelegate? target) where TDelegate : Delegate =>
        Delegate.EnumerateInvocationList(target);
#else
    public static InvocationListEnumerator<TDelegate> EnumerateInvocationList<TDelegate>(TDelegate? target)
        where TDelegate : Delegate =>
        new(Unsafe.As<MulticastDelegate>(target));

    /// <summary>
    /// Provides an enumerator for the invocation list of a delegate.
    /// </summary>
    public struct InvocationListEnumerator<TDelegate>
        where TDelegate : Delegate
    {
        Delegate[] delegates;
        int index = -1;

        internal InvocationListEnumerator(Delegate target) =>
            delegates = target.GetInvocationList();

        public TDelegate Current { get; private set; } = null!;

        public bool MoveNext()
        {
            var index = this.index + 1;
            if (index == delegates.Length)
            {
                return false;
            }

            Current = (TDelegate) delegates[index];
            this.index = index;
            return true;
        }

        [EditorBrowsable(EditorBrowsableState.Never)]
        public InvocationListEnumerator<TDelegate> GetEnumerator() => this;
    }
#endif

}