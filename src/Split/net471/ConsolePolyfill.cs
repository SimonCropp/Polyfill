// <auto-generated />
#pragma warning disable
#if !NET12_0_OR_GREATER
namespace Polyfills;
using System;
using System.Runtime.InteropServices;
using Microsoft.Win32.SafeHandles;
static partial class Polyfill
{
	extension(Console)
	{
		/// <summary>
		/// Gets a <see cref="SafeFileHandle"/> that wraps the operating system handle for standard input.
		/// </summary>
		public static SafeFileHandle OpenStandardInputHandle() =>
			StandardHandleHelper.GetStandardHandle(StandardHandleHelper.StdInput);
		/// <summary>
		/// Gets a <see cref="SafeFileHandle"/> that wraps the operating system handle for standard output.
		/// </summary>
		public static SafeFileHandle OpenStandardOutputHandle() =>
			StandardHandleHelper.GetStandardHandle(StandardHandleHelper.StdOutput);
		/// <summary>
		/// Gets a <see cref="SafeFileHandle"/> that wraps the operating system handle for standard error.
		/// </summary>
		public static SafeFileHandle OpenStandardErrorHandle() =>
			StandardHandleHelper.GetStandardHandle(StandardHandleHelper.StdError);
	}
	static class StandardHandleHelper
	{
		internal const int StdInput = -10;
		internal const int StdOutput = -11;
		internal const int StdError = -12;
		internal static SafeFileHandle GetStandardHandle(int stdHandle)
		{
#if FeatureRuntimeInformation
			if (RuntimeInformation.IsOSPlatform(OSPlatform.Windows))
#else
			if (Environment.OSVersion.Platform == PlatformID.Win32NT)
#endif
			{
				return new(GetStdHandle(stdHandle), ownsHandle: false);
			}
			var fd = stdHandle switch
			{
				StdInput => 0,
				StdOutput => 1,
				StdError => 2,
				_ => throw new ArgumentOutOfRangeException(nameof(stdHandle))
			};
			return new(new(fd), ownsHandle: false);
		}
		[DllImport("kernel32.dll", SetLastError = true)]
		static extern IntPtr GetStdHandle(int nStdHandle);
	}
}
#endif
