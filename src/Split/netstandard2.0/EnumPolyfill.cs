// <auto-generated />
#pragma warning disable
namespace Polyfills;
using System;
using System.Runtime.CompilerServices;
static partial class Polyfill
{
	extension(Enum)
	{
		/// <summary>
		/// Retrieves an array of the values of the constants in a specified enumeration type.
		/// </summary>
		public static TEnum[] GetValues<TEnum>()
			where TEnum : struct, Enum
		{
			var values = Enum.GetValues(typeof(TEnum));
			var result = new TEnum[values.Length];
			Array.Copy(values, result, values.Length);
			return result;
		}
		/// <summary>Returns a <see cref="bool"/> telling whether a given integral value exists in a specified enumeration.</summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public static bool IsDefined<TEnum>(TEnum value)
			where TEnum : struct, Enum =>
			Enum.IsDefined(typeof(TEnum), value);
		/// <summary>
		/// Retrieves an array of the names of the constants in a specified enumeration type.
		/// </summary>
		public static string[] GetNames<TEnum>()
			where TEnum : struct, Enum =>
			Enum.GetNames(typeof(TEnum));
		/// <summary>
		/// Retrieves an array of the values of the constants in a specified enumeration type.
		/// The values are returned as the underlying type of the enum.
		/// </summary>
		public static Array GetValuesAsUnderlyingType(Type enumType)
		{
			var values = Enum.GetValues(enumType);
			var underlyingType = Enum.GetUnderlyingType(enumType);
			var result = Array.CreateInstance(underlyingType, values.Length);
			for (var i = 0; i < values.Length; i++)
			{
				result.SetValue(Convert.ChangeType(values.GetValue(i)!, underlyingType), i);
			}
			return result;
		}
		/// <summary>
		/// Retrieves an array of the values of the constants in a specified enumeration type.
		/// The values are returned as the underlying type of the enum.
		/// </summary>
		public static Array GetValuesAsUnderlyingType<TEnum>()
			where TEnum : struct, Enum =>
			GetValuesAsUnderlyingType(typeof(TEnum));
		/// <summary>
		/// Converts the string representation of the name or numeric value of one or more enumerated constants specified by TEnum to an equivalent enumerated object.
		/// </summary>
		public static TEnum Parse<TEnum>(string value)
			where TEnum : struct, Enum =>
			(TEnum) Enum.Parse(typeof(TEnum), value);
		/// <summary>
		/// Converts the string representation of the name or numeric value of one or more enumerated constants specified by TEnum to an equivalent enumerated object.
		/// </summary>
		public static TEnum Parse<TEnum>(string value, bool ignoreCase)
			where TEnum : struct, Enum =>
			(TEnum) Enum.Parse(typeof(TEnum), value, ignoreCase);
#if FeatureMemory
		/// <summary>
		/// Converts the span of characters representation of the name or numeric value of one or more enumerated constants specified by TEnum to an equivalent enumerated object.
		/// </summary>
		public static TEnum Parse<TEnum>(ReadOnlySpan<char> value)
			where TEnum : struct, Enum =>
			(TEnum)Enum.Parse(typeof(TEnum), value.ToString());
		/// <summary>
		/// Converts the span of characters representation of the name or numeric value of one or more enumerated constants specified by TEnum to an equivalent enumerated object.
		/// </summary>
		public static TEnum Parse<TEnum>(ReadOnlySpan<char> value, bool ignoreCase)
			where TEnum : struct, Enum =>
			(TEnum)Enum.Parse(typeof(TEnum), value.ToString(), ignoreCase);
		/// <summary>
		/// Converts the string representation of the name or numeric value of one or more enumerated constants to an equivalent enumerated object.
		/// </summary>
		public static bool TryParse<TEnum>(ReadOnlySpan<char> value, out TEnum result)
			where TEnum : struct, Enum =>
			Enum.TryParse<TEnum>(value.ToString(), out result);
		/// <summary>
		/// Converts the string representation of the name or numeric value of one or more enumerated constants to an equivalent enumerated object. A parameter specifies whether the operation is case-sensitive. The return value indicates whether the conversion succeeded.
		/// </summary>
		public static bool TryParse<TEnum>(ReadOnlySpan<char> value, bool ignoreCase, out TEnum result)
			where TEnum : struct, Enum =>
			Enum.TryParse<TEnum>(value.ToString(), ignoreCase, out result);
		/// <summary>
		/// Tries to format the value of the enumerated type instance into the provided span of characters.
		/// </summary>
		public static bool TryFormat<TEnum>(TEnum value, Span<char> destination, out int charsWritten, ReadOnlySpan<char> format = default)
			where TEnum : struct, Enum =>
			TryFormatUnconstrained(value, destination, out charsWritten, format);
		internal static bool TryFormatUnconstrained(object value, Span<char> destination, out int charsWritten, ReadOnlySpan<char> format = default)
		{
			string result;
			if (format.Length == 0)
			{
				result = value.ToString()!;
			}
			else
			{
				result = Enum.Format(value.GetType(), value, format.ToString());
			}
			if (result.Length > destination.Length)
			{
				charsWritten = 0;
				return false;
			}
			charsWritten = result.Length;
			result.CopyTo(destination);
			return true;
		}
#endif
	}
}
