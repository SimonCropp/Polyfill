// <auto-generated />
#pragma warning disable
#if FeatureMemory
namespace Polyfills;
using System;
using System.Security.Cryptography;
using System.Text;
static partial class Polyfill
{
	/// <summary>
	/// Imports the public/private keypair from a PKCS#8 EncryptedPrivateKeyInfo structure after decrypting with a byte-based password.
	/// </summary>
	public static void ImportEncryptedPkcs8PrivateKey(
		this RSA target,
		ReadOnlySpan<byte> passwordBytes,
		ReadOnlySpan<byte> source,
		out int bytesRead)
	{
		var (privateKeyInfo, consumed) = Pkcs8Helper.DecryptPkcs8(passwordBytes, source);
		bytesRead = consumed;
		var rsaParams = Pkcs8Helper.ParseRsaPrivateKey(privateKeyInfo);
		target.ImportParameters(rsaParams);
	}
	/// <summary>
	/// Imports the public/private keypair from a PKCS#8 EncryptedPrivateKeyInfo structure after decrypting with a char-based password.
	/// </summary>
	public static void ImportEncryptedPkcs8PrivateKey(
		this RSA target,
		ReadOnlySpan<char> password,
		ReadOnlySpan<byte> source,
		out int bytesRead)
	{
		var passwordBytes = Encoding.UTF8.GetBytes(password.ToArray());
		target.ImportEncryptedPkcs8PrivateKey(passwordBytes, source, out bytesRead);
	}
	static class Pkcs8Helper
	{
		// Well-known OIDs
		static readonly byte[] OidPbes2 = { 0x2A, 0x86, 0x48, 0x86, 0xF7, 0x0D, 0x01, 0x05, 0x0D }; // 1.2.840.113549.1.5.13
		static readonly byte[] OidPbkdf2 = { 0x2A, 0x86, 0x48, 0x86, 0xF7, 0x0D, 0x01, 0x05, 0x0C }; // 1.2.840.113549.1.5.12
		static readonly byte[] OidAes128Cbc = { 0x60, 0x86, 0x48, 0x01, 0x65, 0x03, 0x04, 0x01, 0x02 }; // 2.16.840.1.101.3.4.1.2
		static readonly byte[] OidAes192Cbc = { 0x60, 0x86, 0x48, 0x01, 0x65, 0x03, 0x04, 0x01, 0x16 }; // 2.16.840.1.101.3.4.1.22
		static readonly byte[] OidAes256Cbc = { 0x60, 0x86, 0x48, 0x01, 0x65, 0x03, 0x04, 0x01, 0x2A }; // 2.16.840.1.101.3.4.1.42
		static readonly byte[] OidDesEde3Cbc = { 0x2A, 0x86, 0x48, 0x86, 0xF7, 0x0D, 0x03, 0x07 }; // 1.2.840.113549.3.7
		static readonly byte[] OidHmacSha1 = { 0x2A, 0x86, 0x48, 0x86, 0xF7, 0x0D, 0x02, 0x07 }; // 1.2.840.113549.2.7
		static readonly byte[] OidHmacSha256 = { 0x2A, 0x86, 0x48, 0x86, 0xF7, 0x0D, 0x02, 0x09 }; // 1.2.840.113549.2.9
		static readonly byte[] OidHmacSha384 = { 0x2A, 0x86, 0x48, 0x86, 0xF7, 0x0D, 0x02, 0x0A }; // 1.2.840.113549.2.10
		static readonly byte[] OidHmacSha512 = { 0x2A, 0x86, 0x48, 0x86, 0xF7, 0x0D, 0x02, 0x0B }; // 1.2.840.113549.2.11
		static readonly byte[] OidRsaEncryption = { 0x2A, 0x86, 0x48, 0x86, 0xF7, 0x0D, 0x01, 0x01, 0x01 }; // 1.2.840.113549.1.1.1
		public static (byte[] privateKeyInfo, int bytesRead) DecryptPkcs8(ReadOnlySpan<byte> password, ReadOnlySpan<byte> source)
		{
			var data = source.ToArray();
			var offset = 0;
			// Parse EncryptedPrivateKeyInfo SEQUENCE
			if (data[offset++] != 0x30)
			{
				throw new CryptographicException("Invalid PKCS#8 EncryptedPrivateKeyInfo: expected SEQUENCE");
			}
			var totalLength = ReadLength(data, ref offset);
			var structureEnd = offset + totalLength;
			// Parse encryptionAlgorithm AlgorithmIdentifier SEQUENCE
			if (data[offset++] != 0x30)
			{
				throw new CryptographicException("Invalid AlgorithmIdentifier: expected SEQUENCE");
			}
			var algIdLength = ReadLength(data, ref offset);
			var algIdEnd = offset + algIdLength;
			// Parse algorithm OID
			var algorithmOid = ReadOid(data, ref offset);
			byte[] decryptedData;
			if (OidEquals(algorithmOid, OidPbes2))
			{
				// PBES2 encryption
				decryptedData = DecryptPbes2(password, data, ref offset, algIdEnd, structureEnd);
			}
			else
			{
				throw new CryptographicException($"Unsupported encryption algorithm");
			}
			return (decryptedData, structureEnd);
		}
		static byte[] DecryptPbes2(ReadOnlySpan<byte> password, byte[] data, ref int offset, int algIdEnd, int structureEnd)
		{
			// Parse PBES2-params SEQUENCE
			if (data[offset++] != 0x30)
			{
				throw new CryptographicException("Invalid PBES2-params: expected SEQUENCE");
			}
			var pbes2ParamsLength = ReadLength(data, ref offset);
			// Parse keyDerivationFunc AlgorithmIdentifier
			if (data[offset++] != 0x30)
			{
				throw new CryptographicException("Invalid keyDerivationFunc: expected SEQUENCE");
			}
			var kdfLength = ReadLength(data, ref offset);
			var kdfEnd = offset + kdfLength;
			var kdfOid = ReadOid(data, ref offset);
			if (!OidEquals(kdfOid, OidPbkdf2))
			{
				throw new CryptographicException("Unsupported key derivation function");
			}
			// Parse PBKDF2-params SEQUENCE
			if (data[offset++] != 0x30)
			{
				throw new CryptographicException("Invalid PBKDF2-params: expected SEQUENCE");
			}
			var pbkdf2ParamsLength = ReadLength(data, ref offset);
			var pbkdf2ParamsEnd = offset + pbkdf2ParamsLength;
			// Parse salt (OCTET STRING)
			if (data[offset++] != 0x04)
			{
				throw new CryptographicException("Invalid PBKDF2-params: expected OCTET STRING for salt");
			}
			var saltLength = ReadLength(data, ref offset);
			var salt = new byte[saltLength];
			Array.Copy(data, offset, salt, 0, saltLength);
			offset += saltLength;
			// Parse iterationCount (INTEGER)
			if (data[offset++] != 0x02)
			{
				throw new CryptographicException("Invalid PBKDF2-params: expected INTEGER for iterationCount");
			}
			var iterations = ReadInteger(data, ref offset);
			// Check for optional keyLength
			int? keyLength = null;
			if (offset < pbkdf2ParamsEnd && data[offset] == 0x02)
			{
				offset++; // skip tag
				keyLength = ReadInteger(data, ref offset);
			}
			// Check for optional prf (defaults to HMAC-SHA1)
			HashAlgorithmName hashAlgorithm = HashAlgorithmName.SHA1;
			if (offset < pbkdf2ParamsEnd && data[offset] == 0x30)
			{
				offset++; // skip SEQUENCE tag
				var prfLength = ReadLength(data, ref offset);
				var prfOid = ReadOid(data, ref offset);
				if (OidEquals(prfOid, OidHmacSha256))
				{
					hashAlgorithm = HashAlgorithmName.SHA256;
				}
				else if (OidEquals(prfOid, OidHmacSha384))
				{
					hashAlgorithm = HashAlgorithmName.SHA384;
				}
				else if (OidEquals(prfOid, OidHmacSha512))
				{
					hashAlgorithm = HashAlgorithmName.SHA512;
				}
				else if (OidEquals(prfOid, OidHmacSha1))
				{
					hashAlgorithm = HashAlgorithmName.SHA1;
				}
				// Skip any remaining prf parameters (typically NULL)
				offset = kdfEnd;
			}
			offset = kdfEnd;
			// Parse encryptionScheme AlgorithmIdentifier
			if (data[offset++] != 0x30)
			{
				throw new CryptographicException("Invalid encryptionScheme: expected SEQUENCE");
			}
			var encSchemeLength = ReadLength(data, ref offset);
			var encSchemeEnd = offset + encSchemeLength;
			var encOid = ReadOid(data, ref offset);
			int keySize;
			SymmetricAlgorithm cipher;
			if (OidEquals(encOid, OidAes128Cbc))
			{
				keySize = 16;
				cipher = Aes.Create();
			}
			else if (OidEquals(encOid, OidAes192Cbc))
			{
				keySize = 24;
				cipher = Aes.Create();
			}
			else if (OidEquals(encOid, OidAes256Cbc))
			{
				keySize = 32;
				cipher = Aes.Create();
			}
			else if (OidEquals(encOid, OidDesEde3Cbc))
			{
				keySize = 24;
				cipher = TripleDES.Create();
			}
			else
			{
				throw new CryptographicException("Unsupported encryption algorithm");
			}
			// Parse IV (OCTET STRING)
			if (data[offset++] != 0x04)
			{
				throw new CryptographicException("Invalid encryptionScheme: expected OCTET STRING for IV");
			}
			var ivLength = ReadLength(data, ref offset);
			var iv = new byte[ivLength];
			Array.Copy(data, offset, iv, 0, ivLength);
			offset = algIdEnd;
			// Parse encryptedData (OCTET STRING)
			if (data[offset++] != 0x04)
			{
				throw new CryptographicException("Invalid EncryptedPrivateKeyInfo: expected OCTET STRING for encryptedData");
			}
			var encryptedDataLength = ReadLength(data, ref offset);
			var encryptedData = new byte[encryptedDataLength];
			Array.Copy(data, offset, encryptedData, 0, encryptedDataLength);
			// Derive the key using PBKDF2
			byte[] derivedKey;
			using (var pbkdf2 = new Rfc2898DeriveBytes(password.ToArray(), salt, iterations, hashAlgorithm))
			{
				derivedKey = pbkdf2.GetBytes(keyLength ?? keySize);
			}
			// Decrypt the data
			cipher.Mode = CipherMode.CBC;
			cipher.Padding = PaddingMode.PKCS7;
			cipher.Key = derivedKey;
			cipher.IV = iv;
			using (cipher)
			using (var decryptor = cipher.CreateDecryptor())
			{
				return decryptor.TransformFinalBlock(encryptedData, 0, encryptedData.Length);
			}
		}
		public static RSAParameters ParseRsaPrivateKey(byte[] privateKeyInfo)
		{
			var offset = 0;
			// Parse PrivateKeyInfo SEQUENCE
			if (privateKeyInfo[offset++] != 0x30)
			{
				throw new CryptographicException("Invalid PrivateKeyInfo: expected SEQUENCE");
			}
			ReadLength(privateKeyInfo, ref offset);
			// Parse version (INTEGER, should be 0)
			if (privateKeyInfo[offset++] != 0x02)
			{
				throw new CryptographicException("Invalid PrivateKeyInfo: expected INTEGER for version");
			}
			var versionLength = ReadLength(privateKeyInfo, ref offset);
			offset += versionLength; // Skip version
			// Parse privateKeyAlgorithm AlgorithmIdentifier SEQUENCE
			if (privateKeyInfo[offset++] != 0x30)
			{
				throw new CryptographicException("Invalid privateKeyAlgorithm: expected SEQUENCE");
			}
			var algIdLength = ReadLength(privateKeyInfo, ref offset);
			var algIdEnd = offset + algIdLength;
			var algorithmOid = ReadOid(privateKeyInfo, ref offset);
			if (!OidEquals(algorithmOid, OidRsaEncryption))
			{
				throw new CryptographicException("The key does not represent an RSA key");
			}
			offset = algIdEnd;
			// Parse privateKey (OCTET STRING containing RSAPrivateKey)
			if (privateKeyInfo[offset++] != 0x04)
			{
				throw new CryptographicException("Invalid PrivateKeyInfo: expected OCTET STRING for privateKey");
			}
			var privateKeyLength = ReadLength(privateKeyInfo, ref offset);
			// Parse RSAPrivateKey SEQUENCE
			if (privateKeyInfo[offset++] != 0x30)
			{
				throw new CryptographicException("Invalid RSAPrivateKey: expected SEQUENCE");
			}
			ReadLength(privateKeyInfo, ref offset);
			// Parse version (INTEGER, should be 0)
			if (privateKeyInfo[offset++] != 0x02)
			{
				throw new CryptographicException("Invalid RSAPrivateKey: expected INTEGER for version");
			}
			versionLength = ReadLength(privateKeyInfo, ref offset);
			offset += versionLength; // Skip version
			// Parse RSA parameters
			var rsaParams = new RSAParameters
			{
				Modulus = ReadIntegerBytes(privateKeyInfo, ref offset),
				Exponent = ReadIntegerBytes(privateKeyInfo, ref offset),
				D = ReadIntegerBytes(privateKeyInfo, ref offset),
				P = ReadIntegerBytes(privateKeyInfo, ref offset),
				Q = ReadIntegerBytes(privateKeyInfo, ref offset),
				DP = ReadIntegerBytes(privateKeyInfo, ref offset),
				DQ = ReadIntegerBytes(privateKeyInfo, ref offset),
				InverseQ = ReadIntegerBytes(privateKeyInfo, ref offset)
			};
			// Ensure D, DP, DQ, InverseQ have correct lengths relative to Modulus, P, Q
			rsaParams.D = PadToLength(rsaParams.D, rsaParams.Modulus.Length);
			rsaParams.DP = PadToLength(rsaParams.DP, rsaParams.P.Length);
			rsaParams.DQ = PadToLength(rsaParams.DQ, rsaParams.Q.Length);
			rsaParams.InverseQ = PadToLength(rsaParams.InverseQ, rsaParams.Q.Length);
			return rsaParams;
		}
		static byte[] PadToLength(byte[] data, int length)
		{
			if (data.Length >= length)
			{
				return data;
			}
			var padded = new byte[length];
			Array.Copy(data, 0, padded, length - data.Length, data.Length);
			return padded;
		}
		static int ReadLength(byte[] data, ref int offset)
		{
			var firstByte = data[offset++];
			if (firstByte < 0x80)
			{
				return firstByte;
			}
			var numBytes = firstByte & 0x7F;
			var length = 0;
			for (var i = 0; i < numBytes; i++)
			{
				length = (length << 8) | data[offset++];
			}
			return length;
		}
		static byte[] ReadOid(byte[] data, ref int offset)
		{
			if (data[offset++] != 0x06)
			{
				throw new CryptographicException("Expected OID");
			}
			var length = ReadLength(data, ref offset);
			var oid = new byte[length];
			Array.Copy(data, offset, oid, 0, length);
			offset += length;
			return oid;
		}
		static int ReadInteger(byte[] data, ref int offset)
		{
			var length = ReadLength(data, ref offset);
			var value = 0;
			for (var i = 0; i < length; i++)
			{
				value = (value << 8) | data[offset++];
			}
			return value;
		}
		static byte[] ReadIntegerBytes(byte[] data, ref int offset)
		{
			if (data[offset++] != 0x02)
			{
				throw new CryptographicException("Expected INTEGER");
			}
			var length = ReadLength(data, ref offset);
			var start = offset;
			// Skip leading zero byte if present (used for positive number encoding)
			if (length > 1 && data[offset] == 0x00)
			{
				start++;
				length--;
			}
			var result = new byte[length];
			Array.Copy(data, start, result, 0, length);
			offset = start + length;
			if (data[start - 1] == 0x00)
			{
				offset++; // Account for the skipped leading zero
			}
			return result;
		}
		static bool OidEquals(byte[] oid1, byte[] oid2)
		{
			if (oid1.Length != oid2.Length)
			{
				return false;
			}
			for (var i = 0; i < oid1.Length; i++)
			{
				if (oid1[i] != oid2[i])
				{
					return false;
				}
			}
			return true;
		}
	}
}
#endif
