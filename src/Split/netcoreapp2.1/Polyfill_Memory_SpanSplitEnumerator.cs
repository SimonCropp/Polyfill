// <auto-generated />
#pragma warning disable
#if FeatureMemory && FeatureValueTuple
namespace Polyfills;
using System;
using System.Buffers;
using System.Linq;
using System.Collections;
using System.Collections.Generic;
using System.Runtime.CompilerServices;
static partial class Polyfill
{
	/// <summary>
	/// Enables enumerating each split within a <see cref="ReadOnlySpan{T}"/> that has been divided using one or more separators.
	/// </summary>
	public ref struct SpanSplitEnumerator<T> : IEnumerator<Range>
		where T : IEquatable<T>
	{
		private readonly ReadOnlySpan<T> _source;
		private readonly T _separator = default!;
		private readonly ReadOnlySpan<T> _separatorBuffer;
		private SpanSplitEnumeratorMode _splitMode;
		private int _startCurrent = 0;
		private int _endCurrent = 0;
		private int _startNext = 0;
		public SpanSplitEnumerator<T> GetEnumerator() => this;
		/// <summary>Gets the source span being enumerated.</summary>
		public readonly ReadOnlySpan<T> Source => _source;
		public Range Current => new Range(_startCurrent, _endCurrent);
		internal SpanSplitEnumerator(ReadOnlySpan<T> source, ReadOnlySpan<T> separators)
		{
			_source = source;
			if (typeof(T) == typeof(char) && separators.Length == 0)
			{
				_separatorBuffer = WhiteSpaceChars.AsSpan<T>();
				_splitMode = SpanSplitEnumeratorMode.Any;
				return;
			}
			_separatorBuffer = separators;
			_splitMode = SpanSplitEnumeratorMode.Any;
		}
		internal SpanSplitEnumerator(ReadOnlySpan<T> source, ReadOnlySpan<T> separator, bool treatAsSingleSeparator)
		{
			_source = source;
			_separatorBuffer = separator;
			_splitMode = separator.Length == 0 ? SpanSplitEnumeratorMode.EmptySequence : SpanSplitEnumeratorMode.Sequence;
		}
		internal SpanSplitEnumerator(ReadOnlySpan<T> source, T separator)
		{
			_source = source;
			_separator = separator;
			_splitMode = SpanSplitEnumeratorMode.SingleElement;
		}
		public bool MoveNext()
		{
			int separatorIndex, separatorLength;
			switch (_splitMode)
			{
				case SpanSplitEnumeratorMode.None:
					return false;
				case SpanSplitEnumeratorMode.SingleElement:
					separatorLength = 1;
					separatorIndex = _source.Slice(_startNext)
						.IndexOf(_separator);
					break;
				case SpanSplitEnumeratorMode.Any:
					separatorLength = 1;
					separatorIndex = _source.Slice(_startNext)
						.IndexOfAny(_separatorBuffer);
					break;
				case SpanSplitEnumeratorMode.Sequence:
					separatorIndex = _source.Slice(_startNext).IndexOf(_separatorBuffer);
					separatorLength = _separatorBuffer.Length;
					break;
				case SpanSplitEnumeratorMode.EmptySequence:
					separatorIndex = -1;
					separatorLength = 1;
					break;
				default:
					throw new Exception($"Invalid split mode: {_splitMode}");
			}
			_startCurrent = _startNext;
			if (separatorIndex >= 0)
			{
				_endCurrent = _startCurrent + separatorIndex;
				_startNext = _endCurrent + separatorLength;
			}
			else
			{
				_startNext = _endCurrent = _source.Length;
				_splitMode = SpanSplitEnumeratorMode.None;
			}
			return true;
		}
		object IEnumerator.Current => Current;
		void IEnumerator.Reset() => throw new NotSupportedException();
		void IDisposable.Dispose()
		{
		}
		const string whitespaces = "\t\n\v\f\r\u0020\u0085\u00a0\u1680\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u2028\u2029\u202f\u205f\u3000";
		public static readonly T[] WhiteSpaceChars;
		static SpanSplitEnumerator()
		{
			if (typeof(T) == typeof(char))
			{
				WhiteSpaceChars = whitespaces
					.Cast<T>()
					.ToArray();
			}
		}
	}
}
#endif
