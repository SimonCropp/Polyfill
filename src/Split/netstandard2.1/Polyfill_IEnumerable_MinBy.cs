// <auto-generated />
#pragma warning disable
namespace Polyfills;
using System;
using System.Collections.Generic;
static partial class Polyfill
{
	/// <summary>
	/// Returns the minimum value in a generic sequence according to a specified key selector function.
	/// </summary>
	public static TSource? MinBy<TSource, TKey>(
		this IEnumerable<TSource> source,
		Func<TSource, TKey> keySelector) =>
		MinBy(source, keySelector, null);
	/// <summary>Returns the minimum value in a generic sequence according to a specified key selector function.</summary>
	public static TSource? MinBy<TSource, TKey>(
		this IEnumerable<TSource> source,
		Func<TSource, TKey> keySelector,
		IComparer<TKey>? comparer)
	{
		comparer ??= Comparer<TKey>.Default;
		using var e = source.GetEnumerator();
		if (!e.MoveNext())
		{
			if (default(TSource) is null)
			{
				return default;
			}
			ThrowNoElementsException();
		}
		var value = e.Current;
		var key = keySelector(value);
		if (default(TKey) is null)
		{
			if (key is null)
			{
				var firstValue = value;
				do
				{
					if (!e.MoveNext())
					{
						return firstValue;
					}
					value = e.Current;
					key = keySelector(value);
				}
				while (key is null);
			}
			while (e.MoveNext())
			{
				var nextValue = e.Current;
				var nextKey = keySelector(nextValue);
				if (nextKey is not null && comparer.Compare(nextKey, key) < 0)
				{
					key = nextKey;
					value = nextValue;
				}
			}
		}
		else
		{
			while (e.MoveNext())
			{
				var nextValue = e.Current;
				var nextKey = keySelector(nextValue);
				if (comparer.Compare(nextKey, key) < 0)
				{
					key = nextKey;
					value = nextValue;
				}
			}
		}
		return value;
	}
}
