// <auto-generated />
#pragma warning disable
namespace Polyfills;
using System;
using System.IO;
using System.Collections.Generic;
using System.Diagnostics;
using System.Diagnostics.CodeAnalysis;
using System.Text;
using System.Threading.Tasks;
using System.Threading;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using Microsoft.Win32.SafeHandles;
static partial class Polyfill
{
	extension(File)
	{
		/// <summary>
		/// Appends the specified byte array to the end of the file at the given path.
		/// If the file doesn't exist, this method creates a new file. If the operation is canceled, the task will return in a canceled state.
		/// </summary>
		public static void AppendAllBytes(string path, byte[] bytes)
		{
			using var stream = new FileStream(path, FileMode.Append, FileAccess.Write, FileShare.None);
			stream.Write(bytes, 0, bytes.Length);
		}
		/// <summary>
		/// Asynchronously appends the specified byte array to the end of the file at the given path.
		/// If the file doesn't exist, this method creates a new file. If the operation is canceled, the task will return in a canceled state.
		/// </summary>
		public static async Task AppendAllBytesAsync(string path, byte[] bytes, CancellationToken cancellationToken = default)
		{
			using var stream = new FileStream(path, FileMode.Append, FileAccess.Write, FileShare.None);
			await stream.WriteAsync(bytes, 0, bytes.Length, cancellationToken);
		}
#if FeatureMemory
		/// <summary>
		/// Asynchronously opens a file or creates the file if it does not already exist, appends the specified string to the file using the specified encoding, and then closes the file.
		/// </summary>
		public static Task AppendAllTextAsync(string path, ReadOnlyMemory<char> contents, Encoding encoding, CancellationToken cancellationToken = default) =>
			File.AppendAllTextAsync(path, contents.ToString(), encoding, cancellationToken);
		/// <summary>
		/// Asynchronously opens a file or creates the file if it does not already exist, appends the specified string to the file, and then closes the file.
		/// </summary>
		public static Task AppendAllTextAsync(string path, ReadOnlyMemory<char> contents, CancellationToken cancellationToken = default) =>
			File.AppendAllTextAsync(path, contents.ToString(), cancellationToken);
		/// <summary>
		/// Appends the specified string to the file, creating the file if it does not already exist.
		/// </summary>
		public static void AppendAllText(string path, ReadOnlySpan<char> contents) =>
			File.AppendAllText(path, contents.ToString());
		/// <summary>
		/// Appends the specified string to the file, creating the file if it does not already exist.
		/// </summary>
		public static void AppendAllText(string path, ReadOnlySpan<char> contents, Encoding encoding) =>
			File.AppendAllText(path, contents.ToString(), encoding);
		/// <summary>
		/// Appends the specified byte array to the end of the file at the given path.
		/// If the file doesn't exist, this method creates a new file. If the operation is canceled, the task will return in a canceled state.
		/// </summary>
		public static void AppendAllBytes(string path, ReadOnlySpan<byte> bytes)
		{
			using var stream = new FileStream(path, FileMode.Append, FileAccess.Write, FileShare.None);
			stream.Write(bytes.ToArray(), 0, bytes.Length);
		}
		/// <summary>
		/// Asynchronously creates a new file, writes the specified byte array to the file, and then closes the file. If the target file already exists, it is truncated and overwritten.
		/// </summary>
		public static async Task WriteAllBytesAsync(string path, ReadOnlyMemory<byte> bytes, CancellationToken cancellationToken = default)
		{
			using var stream = new FileStream(path, FileMode.Create, FileAccess.Write, FileShare.None, bufferSize: 4096, useAsync: true);
			await stream.WriteAsync(bytes.ToArray(), 0, bytes.Length, cancellationToken);
		}
		/// <summary>
		/// Creates a new file, writes the specified string to the file, and then closes the file.
		/// If the target file already exists, it is truncated and overwritten.
		/// </summary>
		public static void WriteAllText(string path, ReadOnlySpan<char> contents) =>
			File.WriteAllText(path, contents.ToString());
		/// <summary>
		/// Creates a new file, writes the specified string to the file using the specified encoding, and then closes the file.
		/// If the target file already exists, it is truncated and overwritten.
		/// </summary>
		public static void WriteAllText(string path, ReadOnlySpan<char> contents, Encoding encoding) =>
			File.WriteAllText(path, contents.ToString(), encoding);
		/// <summary>
		/// Asynchronously appends the specified byte array to the end of the file at the given path.
		/// If the file doesn't exist, this method creates a new file. If the operation is canceled, the task will return in a canceled state.
		/// </summary>
		public static Task AppendAllBytesAsync(string path, ReadOnlyMemory<byte> bytes, CancellationToken cancellationToken = default) =>
			AppendAllBytesAsync(path, bytes.ToArray(), cancellationToken);
#endif
		/// <summary>
		/// Moves a specified file to a new location, providing the options to specify a new file name and to replace the destination file if it already exists.
		/// </summary>
		public static void Move(string sourceFileName, string destFileName, bool overwrite)
		{
			sourceFileName = Path.GetFullPath(sourceFileName);
			destFileName = Path.GetFullPath(destFileName);
			if (sourceFileName == destFileName)
			{
				return;
			}
			if (overwrite)
			{
				File.Copy(sourceFileName, destFileName, overwrite: true);
				File.Delete(sourceFileName);
			}
			else
			{
				File.Move(sourceFileName, destFileName);
			}
		}
#if FeatureAsyncInterfaces
		/// <summary>
		/// Asynchronously reads the lines of a file.
		/// </summary>
		public static IAsyncEnumerable<string> ReadLinesAsync(string path, [EnumeratorCancellation] CancellationToken cancellationToken = default) =>
			ReadLinesAsync(path, Encoding.UTF8, cancellationToken);
		/// <summary>
		/// Asynchronously reads the lines of a file that has a specified encoding.
		/// </summary>
		public static async IAsyncEnumerable<string> ReadLinesAsync(string path, Encoding encoding, CancellationToken cancellationToken = default)
		{
			using var stream = new FileStream(path, FileMode.Open, FileAccess.Read, FileShare.Read, bufferSize: 4096, useAsync: true);
			using var reader = new StreamReader(stream, encoding);
			while (!reader.EndOfStream)
			{
				cancellationToken.ThrowIfCancellationRequested();
				var line = await reader.ReadLineAsync();
				if (line != null)
				{
					yield return line;
				}
			}
		}
#endif
	}
	extension(File)
	{
		/// <summary>
		/// Creates a hard link located in <paramref name="path"/> that refers to the same file content as <paramref name="pathToTarget"/>.
		/// </summary>
		/// <param name="path">The path where the hard link should be created.</param>
		/// <param name="pathToTarget">The path of the hard link target.</param>
		/// <returns>A <see cref="FileInfo"/> instance that wraps the newly created file.</returns>
		public static FileSystemInfo CreateHardLink(string path, string pathToTarget)
		{
			var fullPath = Path.GetFullPath(path);
			HardLinkHelper.ValidatePath(pathToTarget, nameof(pathToTarget));
			HardLinkHelper.CreateHardLink(fullPath, Path.GetFullPath(pathToTarget));
			return new FileInfo(path);
		}
	}
#if !NET12_0_OR_GREATER
	extension(File)
	{
		/// <summary>
		/// Opens a handle to the operating system's null device.
		/// </summary>
		public static SafeFileHandle OpenNullHandle()
		{
			return NullDeviceHelper.Open();
		}
	}
	[ExcludeFromCodeCoverage]
	[DebuggerNonUserCode]
#if PolyUseEmbeddedAttribute
	[global::Microsoft.CodeAnalysis.EmbeddedAttribute]
#endif
	static class HardLinkHelper
	{
		internal static void ValidatePath(string path, string paramName)
		{
			if (path is null)
			{
				throw new ArgumentNullException(paramName);
			}
			if (path.Length == 0)
			{
				throw new ArgumentException("Empty file name is not legal.", paramName);
			}
		}
		internal static void CreateHardLink(string path, string pathToTarget)
		{
#if FeatureRuntimeInformation
			if (RuntimeInformation.IsOSPlatform(OSPlatform.Windows))
#else
			if (Environment.OSVersion.Platform == PlatformID.Win32NT)
#endif
			{
				if (!CreateHardLinkW(path, pathToTarget, IntPtr.Zero))
				{
					throw new IOException(
						$"Unable to create hard link '{path}' to '{pathToTarget}'.",
						Marshal.GetHRForLastWin32Error());
				}
			}
			else
			{
				if (link(pathToTarget, path) != 0)
				{
					throw new IOException(
						$"Unable to create hard link '{path}' to '{pathToTarget}'.",
						Marshal.GetHRForLastWin32Error());
				}
			}
		}
		[DllImport("kernel32.dll", EntryPoint = "CreateHardLinkW", CharSet = CharSet.Unicode, SetLastError = true)]
		static extern bool CreateHardLinkW(string lpFileName, string lpExistingFileName, IntPtr lpSecurityAttributes);
		[DllImport("libc", SetLastError = true)]
		static extern int link(string oldpath, string newpath);
	}
	[ExcludeFromCodeCoverage]
	[DebuggerNonUserCode]
#if PolyUseEmbeddedAttribute
	[global::Microsoft.CodeAnalysis.EmbeddedAttribute]
#endif
	static class NullDeviceHelper
	{
		internal static SafeFileHandle Open()
		{
#if FeatureRuntimeInformation
			if (RuntimeInformation.IsOSPlatform(OSPlatform.Windows))
#else
			if (Environment.OSVersion.Platform == PlatformID.Win32NT)
#endif
			{
				const uint GENERIC_READ = 0x80000000;
				const uint GENERIC_WRITE = 0x40000000;
				const uint FILE_SHARE_READ = 1;
				const uint FILE_SHARE_WRITE = 2;
				const uint OPEN_EXISTING = 3;
				var handle = CreateFileW(
					"NUL",
					GENERIC_READ | GENERIC_WRITE,
					FILE_SHARE_READ | FILE_SHARE_WRITE,
					IntPtr.Zero,
					OPEN_EXISTING,
					0,
					IntPtr.Zero);
				if (handle.IsInvalid)
				{
					throw new IOException("Unable to open null device.", Marshal.GetHRForLastWin32Error());
				}
				return handle;
			}
			var stream = new FileStream("/dev/null", FileMode.Open, FileAccess.ReadWrite, FileShare.ReadWrite);
			var rawHandle = stream.SafeFileHandle!.DangerousGetHandle();
			stream.SafeFileHandle!.SetHandleAsInvalid();
			return new(rawHandle, ownsHandle: true);
		}
		[DllImport("kernel32.dll", EntryPoint = "CreateFileW", CharSet = CharSet.Unicode, SetLastError = true)]
		static extern SafeFileHandle CreateFileW(
			string lpFileName,
			uint dwDesiredAccess,
			uint dwShareMode,
			IntPtr lpSecurityAttributes,
			uint dwCreationDisposition,
			uint dwFlagsAndAttributes,
			IntPtr hTemplateFile);
	}
#endif
}
