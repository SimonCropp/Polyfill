// <auto-generated />
#pragma warning disable
#if FeatureAsyncInterfaces
namespace Polyfills;
using System;
using System.Collections.Generic;
using System.Runtime.CompilerServices;
using System.Threading;
using System.Threading.Tasks;
static partial class Polyfill
{
	extension(Task)
	{
		/// <summary>
		/// Creates an async-enumerable that yields completed tasks from the provided collection as they complete.
		/// </summary>
		public static async IAsyncEnumerable<Task> WhenEach(
			IEnumerable<Task> tasks,
			[EnumeratorCancellation] CancellationToken cancellationToken = default)
		{
			if (tasks == null)
			{
				throw new ArgumentNullException(nameof(tasks));
			}
			var remaining = new List<Task>(tasks);
			if (remaining.Count == 0)
			{
				yield break;
			}
			while (remaining.Count > 0)
			{
				cancellationToken.ThrowIfCancellationRequested();
				var completed = await Task.WhenAny(remaining).ConfigureAwait(false);
				remaining.Remove(completed);
				yield return completed;
			}
		}
		/// <summary>
		/// Creates an async-enumerable that yields completed tasks from the provided collection as they complete.
		/// </summary>
		public static async IAsyncEnumerable<Task<TResult>> WhenEach<TResult>(
			IEnumerable<Task<TResult>> tasks,
			[EnumeratorCancellation] CancellationToken cancellationToken = default)
		{
			if (tasks == null)
			{
				throw new ArgumentNullException(nameof(tasks));
			}
			var remaining = new List<Task<TResult>>(tasks);
			if (remaining.Count == 0)
			{
				yield break;
			}
			while (remaining.Count > 0)
			{
				cancellationToken.ThrowIfCancellationRequested();
				var completed = await Task.WhenAny(remaining).ConfigureAwait(false);
				remaining.Remove(completed);
				yield return completed;
			}
		}
	}
}
#endif
