// <auto-generated />
#pragma warning disable
#if FeatureCompression
namespace Polyfills;
using System;
using System.Threading;
using System.Threading.Tasks;
using System.IO;
using System.IO.Compression;
static partial class Polyfill
{
	/// <summary>
	/// Opens the entry from the zip archive.
	/// </summary>
	public static Task<Stream> OpenAsync(this ZipArchiveEntry target, CancellationToken cancellationToken = default)
	{
		cancellationToken.ThrowIfCancellationRequested();
		return Task.FromResult(target.Open());
	}
	/// <summary>
	/// Archives a file by compressing it and adding it to the zip archive.
	/// </summary>
	public static Task<ZipArchiveEntry> CreateEntryFromFileAsync(this ZipArchive target, string sourceFileName, string entryName, CancellationToken cancellationToken = default)
	{
		cancellationToken.ThrowIfCancellationRequested();
		return Task.FromResult(target.CreateEntryFromFile(sourceFileName, entryName));
	}
	/// <summary>
	/// Archives a file by compressing it and adding it to the zip archive.
	/// </summary>
	public static Task<ZipArchiveEntry> CreateEntryFromFileAsync(this ZipArchive target, string sourceFileName, string entryName, CompressionLevel compressionLevel, CancellationToken cancellationToken = default) =>
		Task.FromResult(target.CreateEntryFromFile(sourceFileName, entryName, compressionLevel));
	/// <summary>
	/// Extracts all the files in the zip archive to a directory on the file system.
	/// </summary>
	public static Task ExtractToDirectoryAsync(this ZipArchive target, string destinationDirectoryName, CancellationToken cancellationToken = default)
	{
		cancellationToken.ThrowIfCancellationRequested();
		target.ExtractToDirectory(destinationDirectoryName, false);
		return Task.CompletedTask;
	}
	/// <summary>
	/// Extracts all the files in the zip archive to a directory on the file system.
	/// </summary>
	public static Task ExtractToDirectoryAsync(this ZipArchive target, string destinationDirectoryName, bool overwriteFiles, CancellationToken cancellationToken = default)
	{
		cancellationToken.ThrowIfCancellationRequested();
		target.ExtractToDirectory(destinationDirectoryName, overwriteFiles);
		return Task.CompletedTask;
	}
	/// <summary>
	/// Extracts an entry in the zip archive to a file.
	/// </summary>
	public static Task ExtractToFileAsync(this ZipArchiveEntry source, string destinationFileName, CancellationToken cancellationToken = default)
	{
		cancellationToken.ThrowIfCancellationRequested();
		source.ExtractToFile(destinationFileName);
		return Task.CompletedTask;
	}
	/// <summary>
	/// Extracts an entry in the zip archive to a file.
	/// </summary>
	public static Task ExtractToFileAsync(this ZipArchiveEntry source, string destinationFileName, bool overwrite, CancellationToken cancellationToken = default)
	{
		cancellationToken.ThrowIfCancellationRequested();
		source.ExtractToFile(destinationFileName, overwrite);
		return Task.CompletedTask;
	}
	/// <summary>
	/// Opens the entry from the zip archive with the specified access mode.
	/// </summary>
	public static Stream Open(this ZipArchiveEntry target, FileAccess access) =>
		target.Open();
#if FeatureValueTask
	/// <summary>
	/// Asynchronously opens the entry from the zip archive with the specified access mode.
	/// </summary>
	public static ValueTask<Stream> OpenAsync(this ZipArchiveEntry target, FileAccess access, CancellationToken cancellationToken = default)
	{
		cancellationToken.ThrowIfCancellationRequested();
		return new ValueTask<Stream>(target.Open());
	}
#endif
}
#endif
