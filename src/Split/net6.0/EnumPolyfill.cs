// <auto-generated />
#pragma warning disable
namespace Polyfills;
using System;
using System.Runtime.CompilerServices;
static partial class Polyfill
{
	extension(Enum)
	{
		/// <summary>
		/// Retrieves an array of the values of the constants in a specified enumeration type.
		/// The values are returned as the underlying type of the enum.
		/// </summary>
		public static Array GetValuesAsUnderlyingType(Type enumType)
		{
			var values = Enum.GetValues(enumType);
			var underlyingType = Enum.GetUnderlyingType(enumType);
			var result = Array.CreateInstance(underlyingType, values.Length);
			for (var i = 0; i < values.Length; i++)
			{
				result.SetValue(Convert.ChangeType(values.GetValue(i)!, underlyingType), i);
			}
			return result;
		}
		/// <summary>
		/// Retrieves an array of the values of the constants in a specified enumeration type.
		/// The values are returned as the underlying type of the enum.
		/// </summary>
		public static Array GetValuesAsUnderlyingType<TEnum>()
			where TEnum : struct, Enum =>
			GetValuesAsUnderlyingType(typeof(TEnum));
#if FeatureMemory
		/// <summary>
		/// Tries to format the value of the enumerated type instance into the provided span of characters.
		/// </summary>
		public static bool TryFormat<TEnum>(TEnum value, Span<char> destination, out int charsWritten, ReadOnlySpan<char> format = default)
			where TEnum : struct, Enum =>
			TryFormatUnconstrained(value, destination, out charsWritten, format);
		internal static bool TryFormatUnconstrained(object value, Span<char> destination, out int charsWritten, ReadOnlySpan<char> format = default)
		{
			string result;
			if (format.Length == 0)
			{
				result = value.ToString()!;
			}
			else
			{
				result = Enum.Format(value.GetType(), value, format.ToString());
			}
			if (result.Length > destination.Length)
			{
				charsWritten = 0;
				return false;
			}
			charsWritten = result.Length;
			result.CopyTo(destination);
			return true;
		}
#endif
	}
}
