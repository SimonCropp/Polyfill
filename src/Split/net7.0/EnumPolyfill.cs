// <auto-generated />
#pragma warning disable


namespace Polyfills;

using System;
using System.Runtime.CompilerServices;

static partial class Polyfill
{
    extension(Enum)
    {
#if !NET

        /// <summary>
        /// Retrieves an array of the values of the constants in a specified enumeration type.
        /// </summary>
        //Link: https://learn.microsoft.com/en-us/dotnet/api/system.enum.getvalues?view=net-10.0
        public static TEnum[] GetValues<TEnum>()
            where TEnum : struct, Enum
        {
            var values = Enum.GetValues(typeof(TEnum));
            var result = new TEnum[values.Length];
            Array.Copy(values, result, values.Length);
            return result;
        }

        /// <summary>Returns a <see cref="bool"/> telling whether a given integral value exists in a specified enumeration.</summary>
        //Link: https://learn.microsoft.com/en-us/dotnet/api/system.enum.isdefined?view=net-10.0#system-enum-isdefined-1(-0)
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool IsDefined<TEnum>(TEnum value)
            where TEnum : struct, Enum =>
            Enum.IsDefined(typeof(TEnum), value);

        /// <summary>
        /// Retrieves an array of the names of the constants in a specified enumeration type.
        /// </summary>
        //Link: https://learn.microsoft.com/en-us/dotnet/api/system.enum.getnames?view=net-10.0
        public static string[] GetNames<TEnum>()
            where TEnum : struct, Enum =>
            Enum.GetNames(typeof(TEnum));

#endif


#if FeatureMemory



        /// <summary>
        /// Tries to format the value of the enumerated type instance into the provided span of characters.
        /// </summary>
        //Link: https://learn.microsoft.com/en-us/dotnet/api/system.enum.tryformat?view=net-10.0
        public static bool TryFormat<TEnum>(TEnum value, Span<char> destination, out int charsWritten, ReadOnlySpan<char> format = default)
            where TEnum : struct, Enum =>
            TryFormatUnconstrained(value, destination, out charsWritten, format);

        internal static bool TryFormatUnconstrained(object value, Span<char> destination, out int charsWritten, ReadOnlySpan<char> format = default)
        {
            string result;
            if (format.Length == 0)
            {
                result = value.ToString()!;
            }
            else
            {
                result = Enum.Format(value.GetType(), value, format.ToString());
            }

            if (result.Length > destination.Length)
            {
                charsWritten = 0;
                return false;
            }

            charsWritten = result.Length;
            result.CopyTo(destination);
            return true;
        }

#endif
    }
}