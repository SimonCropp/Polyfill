// <auto-generated />
#pragma warning disable
namespace Polyfills;
using System.Threading.Tasks;
using System.Threading;
using System;
using System.IO;
using System.Security.Cryptography;
using System.Diagnostics;
using System.Diagnostics.CodeAnalysis;
[ExcludeFromCodeCoverage]
[DebuggerNonUserCode]
#if PolyUseEmbeddedAttribute
[global::Microsoft.CodeAnalysis.EmbeddedAttribute]
#endif
#if PolyPublic
public
#endif
static class SHA1Polyfill
{
	extension(SHA1)
	{
		/// <summary>
		/// Computes the hash of a stream using the SHA-1 algorithm.
		/// </summary>
		public static byte[] HashData(Stream source)
		{
			using var hasher = SHA1.Create();
			return hasher.ComputeHash(source);
		}
#if FeatureValueTask
		/// <summary>
		/// Asynchronously computes the hash of a stream using the SHA-1 algorithm.
		/// </summary>
		public static ValueTask<byte[]> HashDataAsync(Stream source, CancellationToken cancellationToken = default)
		{
			cancellationToken.ThrowIfCancellationRequested();
			using var hasher = SHA1.Create();
			return new(hasher.ComputeHash(source));
		}
#endif
#if FeatureMemory
		/// <summary>
		/// Computes the hash of a stream using the SHA-1 algorithm.
		/// </summary>
		public static int HashData(Stream source, Span<byte> destination)
		{
			var hash = HashData(source);
			hash.CopyTo(destination);
			return hash.Length;
		}
#if FeatureValueTask
		/// <summary>
		/// Asynchronously computes the hash of a stream using the SHA-1 algorithm.
		/// </summary>
		public static ValueTask<int> HashDataAsync(Stream source, Memory<byte> destination, CancellationToken cancellationToken = default)
		{
			cancellationToken.ThrowIfCancellationRequested();
			var hash = HashData(source);
			hash.CopyTo(destination);
			return new(hash.Length);
		}
#endif
#endif
	}
}
