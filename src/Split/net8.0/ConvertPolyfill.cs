// <auto-generated />
#pragma warning disable
namespace Polyfills;
using System;
static partial class Polyfill
{
	extension(Convert)
	{
		/// <summary>
		/// Converts a subset of an array of 8-bit unsigned integers to its equivalent string representation that is encoded with lowercase hex characters.
		/// Parameters specify the subset as an offset in the input array and the number of elements in the array to convert.
		/// </summary>
		public static string ToHexStringLower(byte[] inArray, int offset, int length) =>
			ToHexString(inArray, offset, length, "x2");
		/// <summary>
		/// Converts an array of 8-bit unsigned integers to its equivalent string representation that is encoded with lowercase hex characters.
		/// </summary>
		public static string ToHexStringLower(byte[] inArray) =>
			Polyfill.ToHexStringLower(inArray, 0, inArray.Length);
#if FeatureMemory
		/// <summary>
		/// Converts a span of 8-bit unsigned integers to its equivalent string representation that is encoded with lowercase hex characters.
		/// </summary>
		public static string ToHexStringLower(ReadOnlySpan<byte> bytes) =>
			Polyfill.ToHexStringLower(bytes.ToArray());
		/// <summary>
		/// Converts a span of 8-bit unsigned integers to its equivalent span representation that is encoded with uppercase hex characters.
		/// </summary>
		public static bool TryToHexString(ReadOnlySpan<byte> source, Span<char> destination, out int charsWritten)
		{
			if (source.Length > destination.Length / 2)
			{
				charsWritten = 0;
				return false;
			}
			var hexString = Convert.ToHexString(source);
			hexString.CopyTo(destination);
			charsWritten = hexString.Length;
			return true;
		}
		/// <summary>
		/// Converts a span of 8-bit unsigned integers to its equivalent span representation that is encoded with lowercase hex characters.
		/// </summary>
		public static bool TryToHexStringLower(ReadOnlySpan<byte> source, Span<char> destination, out int charsWritten)
		{
			if (source.Length > destination.Length / 2)
			{
				charsWritten = 0;
				return false;
			}
			var hexString = Convert.ToHexStringLower(source);
			hexString.CopyTo(destination);
			charsWritten = hexString.Length;
			return true;
		}
#endif
		static string ToHexString(byte[] inArray, int offset, int length, string format)
		{
			if (length < 0)
				throw new ArgumentOutOfRangeException(nameof(length));
			if (offset < 0)
				throw new ArgumentOutOfRangeException(nameof(offset));
			if (offset > inArray.Length - length)
				throw new ArgumentOutOfRangeException(nameof(offset));
			var hexAlphabet = format == "x2" ? "0123456789abcdef" : "0123456789ABCDEF";
			var chars = new char[length * 2];
			var end = length + offset;
			var charIndex = 0;
			for (var i = offset; i < end; i++)
			{
				var b = inArray[i];
				chars[charIndex++] = hexAlphabet[b >> 4];
				chars[charIndex++] = hexAlphabet[b & 0xF];
			}
			return new string(chars);
		}
	}
}
