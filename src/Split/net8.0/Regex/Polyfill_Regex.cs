// <auto-generated />
#pragma warning disable
namespace Polyfills;
using System;
using System.Text.RegularExpressions;
static partial class Polyfill
{
#if FeatureMemory && FeatureValueTuple
     //Link: https://learn.microsoft.com/en-us/dotnet/api/system.text.regularexpressions.regex.enumeratesplits?view=net-10.0#system-text-regularexpressions-regex-enumeratesplits(system-readonlyspan((system-char)))
    public static ValueSplitEnumerator EnumerateSplits(this Regex regex, ReadOnlySpan<char> input) =>
        new(input, regex, 0, 0);
    //Link: https://learn.microsoft.com/en-us/dotnet/api/system.text.regularexpressions.regex.enumeratesplits?view=net-10.0#system-text-regularexpressions-regex-enumeratesplits(system-readonlyspan((system-char))-system-int32)
    public static ValueSplitEnumerator EnumerateSplits(this Regex regex, ReadOnlySpan<char> input, int count)
    {
        if (count < 0)
        {
            throw new ArgumentOutOfRangeException(nameof(count), "Count must be non-negative.");
        }
        return new ValueSplitEnumerator(input, regex, count, 0);
    }
    //Link: https://learn.microsoft.com/en-us/dotnet/api/system.text.regularexpressions.regex.enumeratesplits?view=net-10.0#system-text-regularexpressions-regex-enumeratesplits(system-readonlyspan((system-char))-system-int32-system-int32)
    public static ValueSplitEnumerator EnumerateSplits(this Regex regex, ReadOnlySpan<char> input, int count, int startat)
    {
        if (count < 0)
        {
            throw new ArgumentOutOfRangeException(nameof(count), "Count must be non-negative.");
        }
        if (startat < 0 || startat > input.Length)
        {
            throw new ArgumentOutOfRangeException(nameof(startat), "Start position must be within the input span.");
        }
        return new ValueSplitEnumerator(input, regex, count, startat);
    }
#endif
}