#pragma warning disable IL2026

public class SanityChecks
{
    [Test]
    public async Task NoPublicTypes()
    {
        var visibleTypes = typeof(SanityChecks).Assembly
            .GetExportedTypes()
            .Where(type => type.Namespace?.StartsWith("System") == true);
#if PolyPublic
#if !NET7_0_OR_GREATER
        await Assert.That(visibleTypes).IsNotEmpty();
#else
        await Task.CompletedTask;
#endif
#else
        await Assert.That(visibleTypes).IsEmpty();
#endif
    }

    [Test]
    public Task ReflectionChecks()
    {
        var errors = new List<string>();
        foreach (var type in typeof(SanityChecks).Assembly.GetTypes())
        {
            if (type.Namespace != null && !type.Namespace.StartsWith("System"))
            {
                continue;
            }

            if (type.IsNested)
            {
                continue;
            }

            if (HasAttribute<TestAttribute>(type))
            {
                continue;
            }

            var name = type.Name;

            // Skip test classes
            if (name.EndsWith("Tests") ||
                name.EndsWith("Test") ||
                name == "SanityChecks" ||
                name == "Memory_CommonPrefixLength")
            {
                continue;
            }
            if (name.EndsWith("Usage") ||
                name.Contains("<") ||
                name.Contains("Sample") ||
                name == "SolutionDirectoryFinder" ||
                name == "AutoGeneratedProgram" ||
                name == "IsReadOnlyAttribute" ||
                name == "IsByRefLikeAttribute" ||
                name == "NullableAttribute" ||
                name == "NullableContextAttribute" ||
                name == "ScopedRefAttribute" ||
                name == "RefSafetyRulesAttribute" ||
                name == "ParamCollectionAttribute" ||
                name == "NativeIntegerAttribute" ||
                name == "ExtensionMarkerAttribute" ||
                name == "ReadOnlySpanAction`2" ||
                name == "SpanAction`2" ||
                name == "FileUtil")
            {
                continue;
            }

            if (type is {IsInterface: false, IsEnum: false})
            {
                if (!HasAttribute<ExcludeFromCodeCoverageAttribute>(type))
                {
                    errors.Add($"{name} must have ExcludeFromCodeCoverageAttribute");
                }

                if (!HasAttribute<DebuggerNonUserCodeAttribute>(type))
                {
                    errors.Add($"{name} must have DebuggerNonUserCodeAttribute");
                }
            }
        }

        if (errors.Count > 0)
        {
            throw new(string.Join("\n", errors));
        }
        return Task.CompletedTask;
    }

    static bool HasAttribute<T>(Type type)
    {
        try
        {
            return type.GetCustomAttribute(typeof(T)) != null;
        }
        catch (Exception e)
        {
            throw new($"Failed to get {typeof(T).Name} from {type.Name}", e);
        }
    }
}
