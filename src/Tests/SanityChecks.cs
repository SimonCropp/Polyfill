using ProjectFilesGenerator;

#pragma warning disable IL2026

public class SanityChecks
{
    [Test]
    public async Task NoPublicTypes()
    {
        var visibleTypes = typeof(SanityChecks).Assembly
            .GetExportedTypes()
            .Where(type => type.Namespace?.StartsWith("System") == true);
#if PolyPublic
#if !NET7_0_OR_GREATER
        await Assert.That(visibleTypes).IsNotEmpty();
#else
        await Task.CompletedTask;
#endif
#else
        await Assert.That(visibleTypes).IsEmpty();
#endif
    }
#if DEBUG
    [Test]
    public Task CodeChecks()
    {
        var dir = Path.Combine(ProjectFiles.SolutionDirectory, "Polyfill");
        var errors = new List<string>();
        foreach (var file in Directory.EnumerateFiles(dir, "*.cs", SearchOption.AllDirectories))
        {
            var directoryName = Path.GetDirectoryName(file)!;
            if (directoryName.Contains("bin") || directoryName.Contains("obj"))
            {
                continue;
            }

            var content = File.ReadAllText(file);
            var requiredText = new[]
            {
                "// <auto-generated />",
                "#pragma warning disable"
            };
            foreach (var required in requiredText)
            {
                if (!content.Contains(required))
                {
                    errors.Add($"{file} must contain '{required}'");
                }
            }
        }

        if (errors.Count > 0)
        {
            throw new(string.Join("\n", errors));
        }
        return Task.CompletedTask;
    }
#endif
    [Test]
    public Task ReflectionChecks()
    {
        var errors = new List<string>();
        foreach (var type in typeof(SanityChecks).Assembly.GetTypes())
        {
            if (type.Namespace != null && !type.Namespace.StartsWith("System"))
            {
                continue;
            }

            if (type.IsNested)
            {
                continue;
            }

            if (HasAttribute<TestAttribute>(type))
            {
                continue;
            }

            var name = type.Name;

            // Skip test classes
            if (name.EndsWith("Tests") ||
                name.EndsWith("Test") ||
                name == "SanityChecks" ||
                name == "Memory_CommonPrefixLength")
            {
                continue;
            }
            if (name.EndsWith("Usage") ||
                name.Contains("<") ||
                name.Contains("Sample") ||
                name == "SolutionDirectoryFinder" ||
                name == "AutoGeneratedProgram" ||
                name == "IsReadOnlyAttribute" ||
                name == "IsByRefLikeAttribute" ||
                name == "NullableAttribute" ||
                name == "NullableContextAttribute" ||
                name == "ScopedRefAttribute" ||
                name == "RefSafetyRulesAttribute" ||
                name == "ParamCollectionAttribute" ||
                name == "NativeIntegerAttribute" ||
                name == "ExtensionMarkerAttribute" ||
                name == "ReadOnlySpanAction`2" ||
                name == "SpanAction`2" ||
                name == "FileUtil")
            {
                continue;
            }

            if (type is {IsInterface: false, IsEnum: false})
            {
                if (!HasAttribute<ExcludeFromCodeCoverageAttribute>(type))
                {
                    errors.Add($"{name} must have ExcludeFromCodeCoverageAttribute");
                }

                if (!HasAttribute<DebuggerNonUserCodeAttribute>(type))
                {
                    errors.Add($"{name} must have DebuggerNonUserCodeAttribute");
                }
            }
        }

        if (errors.Count > 0)
        {
            throw new(string.Join("\n", errors));
        }
        return Task.CompletedTask;
    }

    static bool HasAttribute<T>(System.Type type)
    {
        try
        {
            return type.GetCustomAttribute(typeof(T)) != null;
        }
        catch (Exception e)
        {
            throw new($"Failed to get {typeof(T).Name} from {type.Name}", e);
        }
    }
}
