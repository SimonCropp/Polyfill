// <auto-generated />
#pragma warning disable

#if FeatureCompression
namespace Polyfills;

using System;
using System.Linq;
using System.Threading;
using System.Threading.Tasks;
using System.IO;
using System.IO.Compression;

static partial class Polyfill
{


    /// <summary>
    /// Extracts all the files in the zip archive to a directory on the file system.
    /// </summary>
    //Link: https://learn.microsoft.com/en-us/dotnet/api/system.io.compression.zipfileextensions.extracttodirectory?view=net-10.0#system-io-compression-zipfileextensions-extracttodirectory(system-io-compression-ziparchive-system-string-system-boolean)
    public static void ExtractToDirectory(this ZipArchive target, string destinationDirectoryName, bool overwriteFiles)
    {
        var directoryInfo = Directory.CreateDirectory(destinationDirectoryName);
        var destinationDirectoryFullPath = directoryInfo.FullName;

        if (!destinationDirectoryFullPath.EndsWith(Path.DirectorySeparatorChar))
        {
            destinationDirectoryFullPath = string.Concat(destinationDirectoryFullPath, Path.DirectorySeparatorChar);
        }

        foreach (var source in target.Entries)
        {
            var fullName = SanitizeEntryFilePath(source.FullName);

            var fileDestinationPath = Path.GetFullPath(Path.Combine(destinationDirectoryFullPath, fullName));

            if (!fileDestinationPath.StartsWith(destinationDirectoryFullPath, StringComparison.OrdinalIgnoreCase))
            {
                throw new IOException("Extracting Zip entry would have resulted in a file outside the specified destination directory.");
            }

            if (Path.GetFileName(fileDestinationPath).Length == 0)
            {
                if (source.Length != 0)
                {
                    throw new IOException("Zip entry name ends in directory separator character but contains data.");
                }

                Directory.CreateDirectory(fileDestinationPath);

                // It is a directory
                continue;
            }

            source.ExtractToFile(fileDestinationPath, overwrite: overwriteFiles);
        }
    }

    static string SanitizeEntryFilePath(string fullName)
    {
        var sanitized = new char[fullName.Length];
        for (var index = 0; index < fullName.Length; index++)
        {
            var ch = fullName[index];
            var chars = Path.GetInvalidPathChars();
            if (chars.Contains(ch))
            {
                sanitized[index] = '_';
                continue;
            }

            sanitized[index] = ch;
        }

        return new string(sanitized);
    }
}
#endif